#include <stdio.h>
#define MAXN 150/* Максимален брой върхове в графа */
int n = 9, MAX_VALUE = 10000;/* Брой върхове в графа, макс. стойност на ребро */
int A[MAXN][MAXN] =         /* Матрица на теглата на графа */
{ { 0,  1, 0,  2,  0,  0,  0, 0,  0 },
  { 1,  0, 3,  0, 13,  0,  0, 0,  0 },
  { 0,  3, 0,  4,  0,  3,  0, 0,  0 },
  { 2,  0, 4,  0,  0, 16, 14, 0,  0 },
  { 0, 13, 0,  0,  0, 12,  0, 1, 13 },
  { 0,  0, 3, 16, 12,  0,  1, 0,  1 },
  { 0,  0, 0, 14,  0,  1,  0, 0,  0 },
  { 0,  0, 0,  0,  1,  0,  0, 0,  0 },
  { 0,  0, 0,  0, 13,  1,  0, 0,  0 }
};
bool used[MAXN];
int prev[MAXN];
int T[MAXN]; //най-кратките разстояния до непринадлежащи на дървото върхове

void prim()
{ int MST = 0;  /* цената на минималното покриващо дърво */
  int i, k;
  for (i = 0; i < n; i++) { used[i] = 0; prev[i] = 0; }
  used[0] = 1;  /* избираме произволен начален връх */
  for (i = 0; i < n; i++)
    T[i] = (A[0][i]) ? A[0][i] : MAX_VALUE;
  for (k = 0; k < n - 1; k++)
  { /* търсене на следващо минимално ребро */
    int minDist = MAX_VALUE, j = -1;
    for (i = 0; i < n; i++)
      if (!used[i])
        if (T[i] < minDist) {
          minDist = T[i];
          j = i;
        }
    used[j] = 1;
    printf("(%d,%d) ", prev[j] + 1, j + 1);
    MST += minDist;
    for (i = 0; i < n; i++)
      if (!used[i] && A[j][i])
      { if (T[i] > A[j][i])
        { T[i] = A[j][i];
          prev[i] = j;/* запазване на предшественика, за евентуално отпечатване на следващо минимално ребро */
        }
      }
  }
  printf("\nCenata na MST e %d.\n", MST);
}

int main()
{ prim();
  return 0;
}
