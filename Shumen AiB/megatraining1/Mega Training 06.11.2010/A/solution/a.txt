Задача A2. РАЗСТОЯНИЕ
Класът на Елеонора е адски ШУМЕН (в сравнение с него, дори Големият Взрив е като слабо пукване). Главната причина за това е, че всеки в класа се опитва да говори със свой съученик, който, в повечето случаи, е в другата част на стаята. А както е широко известно – когато двама събеседници си говорят, шумът е пропорционален на квадрата от разстоянието между тях.
Един ден Ели се запитала, каква е максималната олелия, която може да се постигне в нейния клас. За да се определи това, е достатъчно да се знаят разстоянията между всеки два събеседника. Мярка за олелията ще бъде сборът от квадратите на всички такива разстояния. Тъй като става дума за нормално българско училище – всички ученици си говорят по време на час. Класът на Ели се състои от 22 ученика. Понякога някои ученици отсъстват, но N-те ученика в клас винаги са четен брой и всеки ученик води точно един разговор с някой от останалите N–1, като двамата си говорят помежду си и с никой друг. 
Ели е самата прецизност, затова мери разстоянията в милиметри. Класната стая е квадрат със страна 10 000 милиметра. Позицията на един ученик се задава с координатите му, като за начало на координатната система (0,0) е избран един от ъглите на стаята (мястото на учителя). Задачата е да се напише програма distance, която по разположението на N-те ученика в класната стая, да определи максималния възможен шум, който може да се постигне.
Вход. 
На първия ред на стандартния вход ще бъде зададен броят N на учениците (2≤N≤22,N – четно). На всеки от следващите N реда са зададени, разделени с един интервал, по две цели числа x и y(0≤x,y≤10 000) – координатите на поредния ученик. Възможно е да има ученици с еднакви координати – например Пет’р (така изписано, според него, името му изглежда по-хакерско) много обича да седи на главата на Брус Веселия, защото Брус има лаптоп и го носи в клас.
Изход. 
На единствения ред на стандартния изход програмата трябва да изведе максималната възможна олелия, с точност 3 знака след десетичната точка.
 Пример:
Вход
Изход 
Обяснение:
4
1 1
9 2
10 7
2 6
182.000
При данните от примерния вход най-голям сбор се получава, когато ученикът в точка (1,1) си говори с този в точка (10,7) – квадратът на разстоянието е 117.00, а този в точка (2,6) си говори с този в точка (9,2) – квадратът на разстоянието е 65.00. Тогава сборът е 117.00 + 65.00 = 182.00.

Решение:
Тъй като задачата е NP-пълна и няма известен алгоритъм, който да я решава за полиномиално време, то трябва да направим пълно изчерпване. Но ограниченията са твърде големи и затова неинтелигентно изчерпване би било много бавно. Ето защо ще трябва да създадем алгоритъм, базиран на схемата динамично оптимиране. Би могло да се напише решение по схемата greedy, но то не може да разчита на горлям брой точки.
Ако направим наблюдението, че след като изберем първите две точки (т.е. двама ученика, които ще говорят помежду си), остават четен брой точки (N-2 ученика), за които търсим отново максималната възможна сума, т.е. получаваме същата задача, но върху по-малък брой ученици). Следователно трябва да опишем функция, която решава зададената задача и получава като параметър множеството от точки, измежду които може да избира. За да посочим кои от точкитге вече са използвани и кои не са, ще използваме т.н. „битова маска”. Това ще рече – в една цяла променлива за всяка от точките определяме по един бит, който да показва дали съответната точка е използвана. При стойност 1 на бита с номер I  в променливата – точката с номер I е вече използвана, а при стойност на бита нула – точката не е използвана. Следователно, когато функцията получи като параметър битовата маска, може да използва само точките от тези позиции, в които битовете са нули.
Например, достигнали сме до някаква ситуация и битовата маска сочи числото 2835. Неговото представяне в двоична бройна система е: 101100010011. Следователно вече сме използвали точки на позиция 0,1,4,8,9 и 11 (номерацията на битовете започва от 0, като битът с номер 0 е най-младшият бит в двоичното представяне).
Реално погледнато функцията не се нуждае от нищо друго, освен кои точки може да използва и кога да спре. Тъй като от броя на битове със стойност 1 може да се определи колко точки вече са обработени и колко остават, не е нужно на функцията да се подава и този брой, но за удобство (за да не броим всеки път единичните битове в маската) можем да го подаваме на функцията, като втори параметър. Да означим с d(x,y) квадрата на разстоянието междуточките x и y. Динамичното оптимиране ще реализираме под формата на рекурсия със запомняне на резултатите от решените подзадачи в масива T[]. Рекурсивната ни функция ще изглежда така
recurse(mask, level)
{
   if(level>maxlevel) return 0;
   if (T[mask]!=0) return T[mask];
       for(every x,y not in set) 
   { 
	      new_mask=unset(x,y,mask);best_value=0;
      f=d(x,y)+recurse(new_mask,level+1);
		 if(f>best_value) best_value=f;
	   }
	   T[mask]=best_value;
	   return best_value;
	}
В задачата има 2 уловки. Първо в най-лошиия случай може да имаме 11 двойки, които са на разстояние 10000^2+10000^2, чиито общ сбор е 11*200 000 000=2 200 000 000 – т.е. стойност, която е малко над ограниченията на типа int. Има две решения на проблема – или да използваме unsigned int (тъй като нямаме отрицателни числа) или да използваме long long. Второто решение обаче не решава проблема, защото както ще видим по-долу, не можем да спазим ограничението за използваната памет.
Така стигаме и до втория проблем. Само за да пазим таблицата с вече изчислени стойности, които са решенията на подзадачите, ще са ни нужни 222=4 194 304 полета от паметта. Ако използваме long long, то само за масива T[]ще са ни нужни 32 МВ памет (при ограничение 16 МВ). Нещо повече – дори при решението да използваме unsigned int ще са ни нужни точно 16 мегабайта (а ще ни трябват и допълнителни променливи, масив, където да пазим точките и т.н.). И така – паметта не достига. 
При внимателно обмисляне можем да забележим, че тъй като задължително имаме четен брой битове в маската (използваните точките са комбинирани по двойки), то от младшите 21 бита можем еднозначно да определим 22-рия. Ако в младшите 21 бита имаме четен брой единици – значи последния е нула; в противен случай е 1. Това ни дава възможност да направим таблицата за запомняне на резултатите два пъти по-малка и така да намалим необходимата памет с 8 МВ. Сложността на описания алгоритъм е O(N2 * 2N).
Нецелочисления отговор е даден само за да се провери внимателно ли са прочели условието състезателите.
автор: Александър Анриев

