#include <iostream>
#include <algorithm>
#include <string>
// #include <cstring>
using namespace std;

string sKod,sCis;

void Prowerka1 (string s) {
int i,j,d,Gr[5001],bGr,bf=0,NacGr;
char cMin,cMinT;
bool fl[10],Fl;
string ss;

  s='a'+s;
	d=s.size();
	bGr=1;
	Gr[1]=d;
	fill(fl,fl+10,false);
	for (i=d-1;i>=1;i--) {				// Образува групите отзад->напред.
		if (!fl[s[i]-'0']) {
			bf++;
			fl[s[i]-'0']=true;
			if (bf==10)
			 	if (i>1){					// Ако в най-лявата група се срещат всички цифри
					bGr++;					// тя не се добавя.
					Gr[bGr]=i;
					fill(fl,fl+10,false);
					bf=0;
				}
		}
	}
 	cMin='0';
	if (0<bf&&bf<10) {      			// Намира най-малкото липсващо число от първата група
	 for (i=1;i<10;i++) 					// ако тя не е "пълна", т.е. липсва поне една цифра.
	 	if (!fl[i]) {
	 		cMin=i+'0';
	 		break;
	 	}
	}
	if (cMin=='0') {						// Случай, когато в първата група има всички числа от 0 до 9
 		bGr++;								// или в първата група липсва само нулата.
		Gr[bGr]=1;							// Тогава се добавя първата група и се започва проерката от нея.
	 	cMin='1';
	}

	ss=ss+cMin;
// -----------------------------
// Търсене на числата по групите
// -----------------------------
	for (i=bGr;i>=2;i--) {
		fill(fl,fl+10,false);
		Fl=false;
		for (j=Gr[i];j<=Gr[i-1]-1;j++)
		 if (!Fl) {
		 	if (s[j]==cMin)
		 		Fl=true;
		 }
		 else
		 if (Fl)
		 	fl[s[j]-'0']=true;
		cMinT='A';
		for (j=0;j<10;j++)
		 if (!fl[j]) {
		 	cMinT=j+'0';
		 	break;
		 }
		if (cMinT=='A') 								// Случай, когато всички fl[i] са false.
			cMin='0';									// Това е възможно само, ако числото, което
			else											// се търси е 0
			cMin=cMinT;
		ss=ss+cMin;
	}
	sCis=ss;
}

void Prowerka2 (string sc) {
int i,j,d;
char c, cc, MinC;
string s1,s;
bool fl[10];

  d=sc.size();
  s="";
  if (d==1) {
  	if (sc=="1")										// Частен случай за едноцифрено число
  	 s="2";
  	 else
  	 for (c='1';c<='9';c++)
		if (sc[0]!=c) s=s+c;
		else
		break;
  }
  else {													// Число с повече от 1 цифра
  	for (c='1';c<='9';c++)							// Добавя в КОД-а всички цифри, които са
  		if (c<sc[0])									// по-малки от първата и са > 0.
  			s=s+c;
  			else
  			break;
  	for (i=1;i<d;i++) {								// Образува КОД-а след първата цифра
  		fill(fl,fl+10,true);
  		c=sc[i-1];										// Взема предната на текущата
  		if (c>=sc[i]) {								// Ако тя е по-голяма, имам случай например 7 и 2:
  			for (cc=sc[i];cc<=c;cc++) {			// тогава вариант е: 72012345689, който е неприемлив
  				s=s+cc;									// Решението е 2345670189, защото е по-малко число от
  				fl[cc-'0']=false;						// предното. Т.е. първо поставяме всички числа от 2 до 7
  			}
  			for (j=0;j<10;j++)						// След това след 7-цата поставяме останалите
  				if (fl[j]) 								// неизползваните числа във възходящ ред.
  					s=s+char(j+'0');
  		}
  		else {
  			s=s+sc[i]+c;								// Случай 2 и 7. След 2 най-малката липсваща
  			for (j=0;j<=9;j++)						// трябва да е 7. Поставяме я преди 2, става 73
  				if (sc[i]!=(j+'0'))					// и след 2 добавяме всички цифри без 7.
  					s=s+char(j+'0');					// Става 72012345689
  		}
  	}
  }
	while (s[0]=='0')									// Изчиства излишните нули отпред, които се образуват
	 s.erase(s.begin());								// в частните случаи
	sKod=s;
}

int main () {

string sK,sC;
	cin>>sK;												// Въвежда кода
	Prowerka1(sK);										// Влиза с КОД-а
	cout<<sCis<<endl;									// Отпечатва номера, съответстващ на КОД-а
	Prowerka2("29");									// Влиза с НОМЕР-а
	cout<<sKod<<endl; 								// Извежда кода, съответстващ на НОМЕР-а
/*
	Prowerka1(sKod);									// Проверка, дали КОД-ът с минимална дължина
	cout<<sCis<<endl;									// ще изкара въведение номер ?!?!?
*/
  return 0;
}

/*

   987654321123456789 9876543210
   123456789012345678 9012345678
======================================
 110
   1023456789 0123456789
 N=0123456789 0123456789
======================================

//  s="123540123467895012346789012345678912345006789";			// 45501
//		s="91012345678";
//   123 54012346789 5012346789 0123456789 12345006789
//   123 45678901234 5678901234 5678901234 56789012345
//  s="13492012356745678";  							// 29
//	s="10234567890123456789";								// 110
//	s="62583090417028884039886135934572615894909090625947338169672344";

*/


