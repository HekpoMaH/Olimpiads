#include <iostream>
#include <vector>
#include <iomanip>
#include <algorithm>
using namespace std;

struct Tochka {
   int t,st,t1,t2;
   int har,stInt; 
};


vector <Tochka> t;
int N,A,B,bt,NomTA=-1,a[20010];
int intA,intB;
//
// **********************************************************************************************************
// * ТОЧКИ са всички караища на интервали, началната точка А и крайната точка В.
// * Всяка точка има характеристики:
// *   - t          : номера на спирката
// *   - t1 и t2    : краищата на интервла към който принадлежи (т.е. t е равно на t1 или t2)
// *   - har        : показва дали е начало (1), край (2) на инетрвал, т.А (3) или т.В (4)
// *   - st         : мин. стойност в тази точка 
// *   - stInt      : стойността на интервала
// * В масива a[] пазим стойностите .t на масива t[], т.е. a[i]=t[i].t. Използва се за 
// * двоично търсене на край на инетрвал, защото не знам как да търся в масива t[],който е от тип struct :(
// ***********************************************************************************************************
//
// Двоично търсене на края на инервала, 
// на който .t е kk.
// Намира най-левия номер, ако има няколко интервала 
// с еднакви .t 
// Извиква се от NomTKrajInt
int DwT (int kk) {
int *p,rr;
    p=lower_bound(a,a+bt+1,kk);
    rr=p-a;
    if (rr==0) {
     if (a[0]==kk) return 0;
     else return -1;
    }
    else
    if (rr>bt) {
     if (a[bt]==kk) return bt;
     else return -1;
    }
    return rr;
}
//
void Pechat_t1() {
int i;
/*    cout<<char(9)<<t[0].t<<char(9)<<t[0].st<<endl;
    for (i=1; i<=bt;i++) {
     if (t[i].t!=t[i-1].t)   
      cout<<char(9)<<t[i].t<<char(9)<<t[i].st<<endl;
    }
*/
    for (i=0; i<=bt;i++) {
     cout<<setw(4)<<i<<setw(7)<<t[i].t<<setw(7)<<t[i].t1<<setw(7)<<t[i].t2<<setw(7)<<t[i].har;
     cout<<setw(7)<<t[i].stInt<<setw(7)<<t[i].st<<endl;
    }
}
// Критерии за сортиране на масива от точки
bool fff (Tochka a1, Tochka a2) {
    if (a1.t<a2.t) return true;
    else
    if (a1.t==a2.t) {
      return (a1.har<a2.har);
    }
    else
    return false;
}    
// Дадена е точка, която е начало на интервал
// Връща номера на точката, в която е края на интервала
int NomTKrajInt( int NomTNac) {
int nomInt,i,rez, t1, t2;
    t1=t[NomTNac].t1;
    t2=t[NomTNac].t2;
    nomInt=DwT(t2); rez=-1;
    for (i=nomInt; i<=bt;i++)
     if (t[i].t1==t1&&t[i].t2==t2&&t[i].har==2) {
       rez=i;  
       break;   
    }
    return rez;
}
// Намира номера на най-близката вляво точка на NomT,
// която има по-малко .t от на т.NomT
int PrednaT (int NomT) {
int i,rez;
     rez=-1;
     for (i=NomT-1;i>=0;i--)
      if (t[i].t<t[NomT].t||t[i].har==3) {
       rez=i;
       break;
      }
     return rez; 
}
// В началото оптимизира стойността на всички точки след т.А,
// които влизат в инетрвали, съдържащи т.А
void SmenjaStwInt1(int N2) {
int i,NomPr;
    for (i=NomTA+1;i<=bt;i++) {
     if (t[i].t>t[N2].t) break;         // ***тука се проверява спиране на цикъла
     else {   
     t[i].st=min(t[i].st,t[N2].stInt);
     NomPr=PrednaT(i);
     if (NomPr>=0)
      t[i].st=min(t[i].st,t[NomPr].st+t[i].t-t[NomPr].t);
     }
    }
}
// Сменя стойностите на точките, започвайки от N+1 докато
// стигне до точка N2.
void SmenjaStwInt(int N1, int N2) {
int i,NomPr;
// Намира мин. стойност на т.N1
    NomPr=PrednaT(N1);
    if (NomPr>=0)
     t[N1].st=min(t[N1].st,t[NomPr].st+t[N1].t-t[NomPr].t);
// След т.N2 може да има друга, със същата стойност на .t,
// затова се продължава докато (t[i].t>t[N2].t)
    for (i=N1+1;i<=bt;i++) {
     if (t[i].t>t[N2].t) break;         // ***тука се проверява спране на цикъла
     else {   
      t[i].st=min(t[i].st,t[N1].st+t[N2].stInt);
      NomPr=PrednaT(i);
      if (NomPr>=0) {
       t[i].st=min(t[i].st,t[NomPr].st+t[i].t-t[NomPr].t);
//       t[i].st=min(t[i].st,t[NomPr].st+t[N2].stInt);
      }
     }
    }
}

int main () {
int i,j,NomTPrediA=-1,NomTB=-1,NomTKraj,NomPr1,t1,t2,st;
bool fl;

  cin>>N>>A>>B;
  t.resize(N*2+3);
  t[0].t=A;
  t[0].st=0;
  t[0].har=3;
  t[0].t1=t[0].t2=A;
  t[0].stInt=0;
  t[1].t=B;
  t[1].st=1000000;
  t[1].har=4;
  t[1].t1=t[1].t2=B;
  t[1].stInt=0;
  a[0]=A; a[1]=B;
  bt=1;

  for (i=0; i<N;i++) {
   cin>>t1>>t2>>st;
   bt++;
   t[bt].t=t1;
   t[bt].st=1000000;
   t[bt].t1=t1;
   t[bt].t2=t2;
   t[bt].har=1;
   t[bt].stInt=st;
   a[bt]=t[bt].t;
   bt++;
   t[bt].t=t2;
   t[bt].st=1000000;
   t[bt].t1=t1;
   t[bt].t2=t2;
   t[bt].har=2;
   t[bt].stInt=st;
   a[bt]=t[bt].t;
  }  
  sort(t.begin(),t.begin()+bt+1,fff);
  sort(a,a+bt+1);
  t[0].st=0;
//  Pechat_t1();
// *****************************************************
// Определя
//  - NomTA - номера на точката на А
//  - NomTВ - номера на точката на В
//  - NomTPrediA - номера на най-лявата точка преди А,
//                 която е начало на интервал, който
//                 съдържа А
  for (i=0;i<=bt;i++) 
   if (t[i].har==3) NomTA=i;
   else  
   if (t[i].t1<=A&&A<=t[i].t2&&t[i].har==1) {
    if (NomTPrediA==-1) NomTPrediA=i;
   }
   else
   if (t[i].har==4) {
    NomTB=i;
    break;
   }
//  cout<<NomTPrediA<<" "<<NomTA<<" "<<NomTB<<endl;
// *****************************************************
// Ако А се съдържа в някой интервал, сменя стойностите 
// на всички точки от А до края на всеки от интервалите, които я съдържат
//  cout<<A<<endl; 
  if (NomTPrediA>=0) {
   for (i=NomTPrediA;i<=bt;i++) {
    if (t[i].t1>A) break;
    else 
    if (t[i].har==1) {
     NomTKraj=NomTKrajInt(i);
//     cout<<"("<<i<<" ; "<<NomTKraj<<")\n";
     SmenjaStwInt1(NomTKraj);     
    } 
   }
  }
//  Pechat_t1();
// ******************************************************
// Намира стойностите на точките от А+1 до В
  for (i=NomTA+1;i<=NomTB;i++) {
    j=PrednaT(i);                                       // Независимо дали е край или начало на инервал
    t[i].st=min(t[i].st,t[j].st+t[i].t-t[j].t);         // се проверява стойността на точка i.
    if (t[i].har==1) {                                  // Интересува ни само точка, която е начало на интервал
     NomTKraj=NomTKrajInt(i);                           // Намира края на интервала
     SmenjaStwInt(i,NomTKraj);                          // Сменя стойностите на точките в интервала
//     cout<<"("<<i<<" ; "<<NomTKraj<<")\n";     
//     Pechat_t1();
     }
     else 
     if (t[i].har==4){                                  // Ако е стигнало до точка В
      NomPr1=PrednaT(i);
      if (NomPr1>=0)
       t[i].st=min(t[i].st,t[NomPr1].st+t[i].t-t[NomPr1].t);
     }
    } 
//  Pechat_t1();  
  cout<<t[NomTB].st<<endl;
//  system ("pause");
  return 0;
}
/*
//
4 7 34
5 16 10
10 14 2
10 37 20
18 35 5
// 42   1
6 2 57
3 25 16
10 14 2
12 16 2
30 45 10
35 55 13
35 40 3

// 39   2
6 3 55
3 25 16
10 14 2
12 16 2
30 45 10
35 55 13
35 40 3

// 41   3
6 1 55
3 25 16
10 14 2
12 16 2
30 45 10
35 55 13
35 40 3

// 43   4
6 3 59
3 25 16
10 14 2
12 16 2
30 45 10
35 55 13
35 40 3

// 39   5
6 3 54
3 25 16
10 14 2
12 16 2
30 45 10
35 55 13
35 40 3

// 32   6 
6 3 46
3 25 16
10 14 2
12 16 2
30 45 10
35 55 13
35 40 3

// 33   7
6 15 54
3 25 16
10 14 2
12 16 2
30 45 10
35 55 13
35 40 3

// 37   8
6 9 54
3 25 16
10 14 2
12 16 2
30 45 10
35 55 13
35 40 3

// 8    9
6 46 54
3 25 16
10 14 2
12 16 2
30 45 10
35 55 13
35 40 3

// 7    10
6 36 44
3 25 16
10 14 2
12 16 2
30 45 10
35 55 13
35 40 3

// 1
6 8 10
3 15 10
5 8 1
7 10 1
20 29 8
21 27 4
21 33 10

// 27
6 1 33
3 15 10
5 8 1
7 10 1
20 29 8
21 27 4
21 33 10

// 31
6 1 37
3 15 10
5 8 1
7 10 1
20 29 8
21 27 4
21 33 10

// 7
6 1 11
3 15 10
5 8 1
7 10 1
20 29 8
21 27 4
21 33 10

// 25
6 3 33
3 15 10
5 8 1
7 10 1
20 29 8
21 27 4
21 33 10

// 20
6 3 28
3 15 10
5 8 1
7 10 1
20 29 8
21 27 4
21 33 10

// 
6 3 28
3 15 10
5 8 1
7 10 1
20 29 8
21 27 4
21 33 10

// 30
10 6 44
1 13 9
2 6 2
6 18 10
9 12 1
18 21 1
19 25 4
21 27 4
26 32 4
39 46 4
40 48 4

// 22
6 18 41
10 24 11
12 29 10
12 24 8
14 20 4
29 46 12
40 46 4 

// 9 
6 18 27
10 24 11
12 29 10
12 24 8
14 20 4
29 46 9
40 46 4 

// 19
6 18 46
10 24 11
12 29 10
12 24 8
14 20 4
29 46 9
40 46 4 

// 19
6 12 41
10 24 11
12 29 10
12 24 8
14 20 4
29 46 9
40 46 4 

// 8 
6 10 20
10 24 11
12 29 10
12 24 8
14 20 4
29 46 9
40 46 4 

// 28 
6 7 50
10 24 11
12 29 10
12 24 8
14 20 4
29 46 9
40 46 4 

// 24
6 7 46
10 24 11
12 29 10
12 24 8
14 20 4
29 46 9
40 46 4 

// 21
6 10 46
10 24 11
12 29 10
12 24 8
14 20 4
29 46 9
40 46 4 

// 5
6 9 14
10 24 11
12 29 10
12 24 8
14 20 4
29 46 9
40 46 4 

// 19
6 14 45
10 24 11
12 29 10
12 24 8
14 20 4
29 46 9
40 46 4 

// 21
7 8 36
5 14 8
10 14 3
10 25 8
16 34 12
16 20 3
20 25 3
25 30 4


// Otg: 27
7 1 43
5 17 5
12 17 3
12 33 10
21 26 4
26 33 5
26 41 8
36 41 4
// Otg: 12
8 9 43
12 33 10
21 26 4
12 17 3
36 41 4
5 17 5
26 33 5
26 41 8
1 26 2
// Otg: 21 
7 5 41
5 17 5
12 17 3
12 33 10
21 26 4
26 33 5
26 41 8
36 41 4

// Otg: 17
4 2 22
1 7 4
7 12 4
12 20 7
20 30 8
// Otg: 24
3 6 33
5 12 5
20 25 3
30 40 6

//
6 15 42
5 21 12
16 20 3
23 36 9
23 30 5
32 36 3
30 42 9
*/
