#include <iostream>
using namespace std;

bool graph[1001][1001];     // В graph се представя първоначалният граф чрез
                            // матрица на инцидентност (попълва се само над 
                            // главния диагонал)
int comgraph[1001][1001];   // В comgraph се представя допълнението на 
                            // първоначалния граф чрез списъци на
                            //инцидентните върхове за всеки връх.
bool label[1001];           // в label се слага индикация дали връх с номер i
                            // вече е посетен при обхождането в дълбочина:
                            // label[i]=0 - още не е посетен
                            // label[i]=1 - вече е посетен
int lc=0;                   // В lc се броят вече посетените върхове
int cc=0;                   // В cc се броят компонентите на свързаност в
                            // допълнението на началния граф.

int n,m;

void graphinput()
{
  int i,j,u,v;
  // Въвеждат се брой върхове и брой ребра
  cin >> n >> m;
  // Нулира се матрицата на инцидентност
  for (i=1;i<=(n-1);i++)
    for (j=i+1;j<=n;j++)
      graph[i][j] = 0;
  //Въвеждат се ребрата и се попълва матрицата на инцидентност над гл. 
  // диагонал    
  for (i=1;i<=m;i++)
  {
    cin >> u >> v;
    if (v<u)
    {
      j=v;
      v=u;
      u=j;
    }  
    graph[u][v]=1;
  }     
}

void buildcomgraph()
{
  int i,j,k;
  // Нулира се броят на инцидентните върхове за всеки връх
  for (i=1;i<=n;i++)
    comgraph[i][0] = 0;
  // Обхожда се матрицата на инцидентност над гл. диагонал отгоре надолу и
  // отляво надясно и се попълват списъците на инцидентните върхове за
  // всеки връх от допълнението на началния граф 
  for (i=1;i<=(n-1);i++)
    for (j=i+1;j<=n;j++)
      if (graph[i][j] == 0)
      {
        k = ++comgraph[i][0];
        comgraph[i][k] = j;
        k = ++comgraph[j][0];
        comgraph[j][k] = i;
      }
}

void DFScomgraph(int v) // "изтегля" компонента на свързаност в доп. граф,                       // която съдържа връх с номер v
{
  int k,i,j;   
  label[v] = 1;
  lc++;
  k = comgraph[v][0];
  if (k > 0)
    for (i=1;i<=k;i++)
    {
      j = comgraph[v][i];
      if (label[j] == 0)
        DFScomgraph(j);  
    }      
}

int main()
{
  int i,j;
  graphinput();          //Въвежда се началният граф
  buildcomgraph();       // Построява се допълнителният граф
  // Първоначално всички върхове се обявяват за непосетени
  for (i=1;i<=n;i++)
    label[i] = 0;
  // Докато има все още непосетени върхове, търси първия непосетен
  // и се обръща с него към DFScomgraph, за обходи компонентата на 
  // свързаност, която го съдържа. Когато я обходи, добавя 1 към
  // брояча на компонентите на свързаност
  for (i=1;((i<=n)&&(lc < n));i++)
  {
    if (label[i] == 0)
      {
        DFScomgraph(i);
        cc++;
      }  
  } 
  // Минималният брой стари ребра, които трябва да бъдат запазени в новия 
  // граф е равен на броя на компонентите на свързаност в доп. граф минус 
  // едно.  
  cout << cc-1 << endl;
  
  return 0;  
}
