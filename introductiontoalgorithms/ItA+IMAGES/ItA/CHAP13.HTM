<HTML><HEAD><TITLE>Intro to Algorithms: CHAPTER 13: BINARY SEARCH TREES</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><a href="chap14.htm"><img align=right src="../../images/next.gif" alt="Next Chapter" border=0></A><a href="toc.htm"><img align=right src="../../images/toc.gif" alt="Return to Table of Contents" border=0></A><a href="chap12.htm"><img align=right src="../../images/prev.gif" alt="Previous Chapter" border=0></A><h1><a name="07d7_0001">CHAPTER 13: BINARY SEARCH TREES<a name="07d7_0001"></h1><P>Search trees are data structures that support many dynamic-set operations, including <FONT FACE="Courier New" SIZE=2>SEARCH</FONT>, <FONT FACE="Courier New" SIZE=2>MINIMUM</FONT>, <FONT FACE="Courier New" SIZE=2>MAXIMUM</FONT>, <FONT FACE="Courier New" SIZE=2>PREDECESSOR</FONT>, <FONT FACE="Courier New" SIZE=2>SUCCESSOR</FONT>, <FONT FACE="Courier New" SIZE=2>INSERT</FONT>, and <FONT FACE="Courier New" SIZE=2>DELETE</FONT>. Thus, a search tree can be used both as a dictionary and as a priority queue.<P>Basic operations on a binary search tree take time proportional to the height of the tree. For a complete binary tree with <I>n</I> nodes, such operations run in <IMG SRC="../IMAGES/bound.gif">(lg <I>n</I>) worst-case time. If the tree is a linear chain of <I>n</I> nodes, however, the same operations take <IMG SRC="../IMAGES/bound.gif">(<I>n</I>) worst-case time. We shall see in Section 13.4 that the height of a randomly built binary search tree is <I>O</I>(lg <I>n</I>), so that basic dynamic-set operations take <IMG SRC="../IMAGES/bound.gif">(lg <I>n</I>) time.<P>In practice, we can't always guarantee that binary search trees are built randomly, but there are variations of binary search trees whose worst-case performance on basic operations can be guaranteed to be good. Chapter 14 presents one such variation, red-black trees, which have height <I>O</I>(lg <I>n</I>). Chapter 19 introduces B-trees, which are particularly good for maintaining data bases on random-access, secondary (disk) storage.<P>After presenting the basic properties of binary search trees, the following sections show how to walk a binary search tree to print its values in sorted order, how to search for a value in a binary search tree, how to find the minimum or maximum element, how to find the predecessor or successor of an element, and how to insert into or delete from a binary search tree. The basic mathematical properties of trees were introduced in Chapter 5.<P><h1><a name="07d9_1488">13.1 What is a binary search tree?<a name="07d9_1488"></h1><P><a name="07d9_147e"><a name="07d9_147f"><a name="07d9_1480">A binary search tree is organized, as the name suggests, in a binary tree, as shown in Figure 13.1. Such a tree can be represented by a linked data structure in which each node is an object. In addition to a <I>key</I> field, each node contains fields <I>left, right,</I> and <I>p</I> that point to the nodes corresponding to its left child, its right child, and its parent, respectively. If a child or the parent is missing, the appropriate field contains the value <FONT FACE="Courier New" SIZE=2>NIL</FONT>. The root node is the only node in the tree whose parent field is <FONT FACE="Courier New" SIZE=2>NIL</FONT>.<P><img src="245_a.gif"><P><h4><a name="07d9_1489">Figure 13.1 Binary search trees. For any node x, the keys in the left subtree of x are at most key[x], and the keys in the right subtree of x are at least key[x]. Different binary search trees can represent the same set of values. The worst-case running time for most search-tree operations is proportional to the height of the tree. (a) A binary search tree on 6 nodes with height 2. (b) A less efficient binary search tree with height 4 that contains the same keys.<a name="07d9_1489"></sub></sup></h4><P><a name="07d9_1481">The keys in a binary search tree are always stored in such a way as to satisfy the <I><B>binary-search-tree property</I></B>:<P>Let <I>x</I> be a node in a binary search tree. If <I>y</I> is a node in the left subtree of <I>x,</I> then <I>key</I>[<I>y</I>]<I> </I><IMG SRC="../IMAGES/lteq12.gif"> key<I>[</I>x<I>]</I>.<I> If </I>y<I> is a node in the right subtree of </I>x,<I> then </I>key<I>[</I>x<I>]</I> <I><IMG SRC="../IMAGES/lteq12.gif"> key</I>[<I>y</I>]<I>.</I><P>Thus, in Figure 13.1(a), the key of the root is 5, the keys 2, 3, and 5 in its left subtree are no larger than 5, and the keys 7 and 8 in its right subtree are no smaller than 5. The same property holds for every node in the tree. For example, the key 3 in Figure 13.1(a) is no smaller than the key 2 in its left subtree and no larger than the key 5 in its right subtree.<P><a name="07d9_1482"><a name="07d9_1483"><a name="07d9_1484"><a name="07d9_1485"><a name="07d9_1486">The binary-search-tree property allows us to print out all the keys in a binary search tree in sorted order by a simple recursive algorithm, called an <I><B>inorder tree walk</I></B><I>.</I> This algorithm derives its name from the fact that the key of the root of a subtree is printed between the values in its left subtree and those in its right subtree. (Similarly, a <I><B>preorder tree walk</I></B> prints the root before the values in either subtree, and a <I><B>postorder tree walk</I></B> prints the root after the values in its subtrees.) To use the following procedure to print all the elements in a binary search tree <I>T</I>, we call <FONT FACE="Courier New" SIZE=2>INORDER</FONT>-<FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>WALK</FONT>( <I>root</I>[<I>T</I>]).<P><pre><a name="07d9_1487">INORDER-TREE-WALK(<I>x</I>)</sub></sup></pre><P><pre>1  <B>if</B> <I>x</I> <IMG SRC="../IMAGES/noteq.gif"> NIL</sub></sup></pre><P><pre>2      <B>then</B> INORDER-TREE-WALK (<I>left</I>[<I>x</I>])</sub></sup></pre><P><pre>3           print <I>key</I>[<I>x</I>]</sub></sup></pre><P><pre>4           INORDER-TREE-WALK (<I>right</I>[<I>x</I>])</sub></sup></pre><P>As an example, the inorder tree walk prints the keys in each of the two binary search trees from Figure 13.1 in the order 2, 3, 5, 5, 7, 8. The correctness of the algorithm follows by induction directly from the binary-search-tree property. It takes <IMG SRC="../IMAGES/bound.gif">(<I>n</I>) time to walk an <I>n</I>-node binary search tree, since after the initial call, the procedure is called recursively exactly twice for each node in the tree--once for its left child and once for its right child.<P><h2><a name="07da_148c">Exercises<a name="07da_148c"></h2><P><a name="07da_148d">13.1-1<a name="07da_148d"><P>Draw binary search trees of height 2, 3, 4, 5, and 6 on the set of keys {1, 4, 5, 10, 16, 17, 21}.<P><a name="07da_148e">13.1-2<a name="07da_148e"><P><a name="07da_1488"><a name="07da_1489">What is the difference between the binary-search-tree property and the heap property (7.1)? Can the heap property be used to print out the keys of an <I>n</I>-node tree in sorted order in <I>O</I>(<I>n</I>) time? Explain how or why not.<P><a name="07da_148f">13.1-3<a name="07da_148f"><P><a name="07da_148a">Give a nonrecursive algorithm that performs an inorder tree walk. (<I>Hint: </I>There is an easy solution that uses a stack as an auxiliary data structure and a more complicated but elegant solution that uses no stack but assumes that two pointers can be tested for equality.)<P><a name="07da_1490">13.1-4<a name="07da_1490"><P>Give recursive algorithms that perform preorder and postorder tree walks in <IMG SRC="../IMAGES/bound.gif">(<I>n</I>) time on a tree of <I>n</I> nodes.<P><a name="07da_1491">13.1-5<a name="07da_1491"><P><a name="07da_148b">Argue that since sorting <I>n</I> elements takes <IMG SRC="../IMAGES/omega12.gif"> (<I>n </I>lg<I> n</I>) time in the worst case in the comparison model, any comparison-based algorithm for constructing a binary search tree from an arbitrary list of <I>n</I> elements takes <IMG SRC="../IMAGES/omega12.gif"> (<I>n </I>lg<I> n</I>)<I> </I>time in the worst case.<P><P><P><h1><a name="07db_148d">13.2 Querying a binary search tree<a name="07db_148d"></h1><P><a name="07db_148c">The most common operation performed on a binary search tree is searching for a key stored in the tree. Besides the <FONT FACE="Courier New" SIZE=2>SEARCH</FONT> operation, binary search trees can support such queries as <FONT FACE="Courier New" SIZE=2>MINIMUM</FONT>, <FONT FACE="Courier New" SIZE=2>MAXIMUM</FONT>, <FONT FACE="Courier New" SIZE=2>SUCCESSOR</FONT>, and <FONT FACE="Courier New" SIZE=2>PREDECESSOR</FONT>. In this section, we shall examine these operations and show that each can be supported in time <I>O</I>(<I>h</I>) on a binary search tree of height <I>h.</I><P><img src="247_a.gif"><P><h4><a name="07db_148e">Figure 13.2 Queries on a binary search tree. To search for the key 13 in the tree, the path 15 <IMG SRC="../IMAGES/arrow12.gif"> 6 <IMG SRC="../IMAGES/arrow12.gif"> 7 <IMG SRC="../IMAGES/arrow12.gif"> 13 is followed from the root. The minimum key in the tree is 2, which can be found by following left pointers from the root. The maximum key 20 is found by following right pointers from the root. The successor of the node with key 15 is the node with key 17, since it is the minimum key in the right subtree of 15. The node with key 13 has no right subtree, and thus its successor is its lowest ancestor whose left child is also an ancestor. In this case, the node with key 15 is its successor.<a name="07db_148e"></sub></sup></h4><P><h2>Searching</h2><P><a name="07dc_148d"><a name="07dc_148e">We use the following procedure to search for a node with a given key in a binary search tree. Given a pointer to the root of the tree and a key <I>k,</I> <FONT FACE="Courier New" SIZE=2>TREE-</FONT><FONT FACE="Courier New" SIZE=2>SEARCH</FONT> returns a pointer to a node with key <I>k</I> if one exists; otherwise, it returns <FONT FACE="Courier New" SIZE=2>NIL</FONT>.<P><pre><a name="07dc_148f">TREE-SEARCH (<I>x, k</I>)</sub></sup></pre><P><pre>1 <B>if</B> <I>x</I> = NIL or <I>k = key</I>[<I>x</I>]</sub></sup></pre><P><pre>2     <B>then return</B> <I>x</I></sub></sup></pre><P><pre>3  <B>if</B> <I>k &lt; key</I>[<I>x</I>]</sub></sup></pre><P><pre>4     <B>then return</B> TREE-SEARCH <I>(left</I>[<I>x</I>],<I> k)</I></sub></sup></pre><P><pre>5     <B>else return</B> TREE-SEARCH <I>(right</I>[<I>x</I>],<I> k)</I></sub></sup></pre><P>The procedure begins its search at the root and traces a path downward in the tree, as shown in Figure 13.2. For each node <I>x </I>it encounters, it compares the key <I>k</I> with <I>key</I>[<I>x</I>]<I>.</I> If the two keys are equal, the search terminates. If <I>k</I> is smaller than <I>key</I>[<I>x</I>]<I>,</I> the search continues in the left subtree of <I>x,</I> since the binary-search-tree property implies that <I>k</I> could not be stored in the right subtree. Symmetrically, if <I>k</I> is larger than <I>key</I>[<I>k</I>]<I>,</I> the search continues in the right subtree. The nodes encountered during the recursion form a path downward from the root of the tree, and thus the running time of <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>SEARCH</FONT> is <I>O</I>(<I>h</I>)<I>,</I> where <I>h</I> is the height of the tree.<P>The same procedure can be written iteratively by "unrolling" the recursion into a <B>while</B> loop. On most computers, this version is more efficient.<P><pre><a name="07dc_1490">ITERATIVE-TREE-SEARCH (<I>x,k</I>)</sub></sup></pre><P><pre>1  <B>while</B> <I>x</I> <IMG SRC="../IMAGES/noteq.gif"> NIL and <I>k</I> <IMG SRC="../IMAGES/noteq.gif"> <I>key</I>[<I>x</I>]</sub></sup></pre><P><pre>2      <B>do if</B> <I>k</I> &lt; <I>key</I>[<I>x</I>]</sub></sup></pre><P><pre>3            <B>then</B> <I>x</I> <IMG SRC="../IMAGES/arrlt12.gif"> <I>left</I>[<I>x</I>]</sub></sup></pre><P><pre>4            <B>else</B> <I>x</I> <IMG SRC="../IMAGES/arrlt12.gif"> <I>right</I>[<I>x</I>]</sub></sup></pre><P><pre>5  <B>return</B> <I>x</I></sub></sup></pre><P><P><h2>Minimum and maximum</h2><P><a name="07dd_1491"><a name="07dd_1492"><a name="07dd_1493"><a name="07dd_1494">An element in a binary search tree whose key is a minimum can always be found by following <I>left</I> child pointers from the root until a <FONT FACE="Courier New" SIZE=2>NIL</FONT> is encountered, as shown in Figure 13.2. The following procedure returns a pointer to the minimum element in the subtree rooted at a given node <I>x.</I><P><pre><a name="07dd_1495">TREE-MINIMUM (<I>x</I>)</sub></sup></pre><P><pre>1  <B>while</B> <I>left</I>[<I>x</I>] <IMG SRC="../IMAGES/noteq.gif"> NIL</sub></sup></pre><P><pre>2      <B>do</B> <I>x</I> <IMG SRC="../IMAGES/arrlt12.gif"> <I>left</I>[<I>x</I>]</sub></sup></pre><P><pre>3  <B>return</B> <I>x</I></sub></sup></pre><P>The binary-search-tree property guarantees that <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>MINIMUM</FONT> is correct. If a node <I>x</I> has no left subtree, then since every key in the right subtree of <I>x</I> is at least as large as <I>key</I>[<I>x</I>]<I>,</I> the minimum key in the subtree rooted at <I>x</I> is <I>key</I>[<I>x</I>]<I>.</I> If node <I>x</I> has a left subtree, then since no key in the right subtree is smaller than <I>key</I>[<I>x</I>] and every key in the left subtree is not larger than <I>key</I>[<I>x</I>], the minimum key in the subtree rooted at <I>x</I> can be found in the subtree rooted at <I>left</I>[<I>x</I>]<I>.</I><P>The pseudocode for <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>MAXIMUM</FONT> is symmetric.<P><pre><a name="07dd_1496">TREE-MAXIMUM (<I>x)</I></sub></sup></pre><P><pre>1  <B>while</B> <I>right</I>[<I>x</I>] <IMG SRC="../IMAGES/noteq.gif"> NIL</sub></sup></pre><P><pre>2      <B>do</B> <I>x</I> <IMG SRC="../IMAGES/arrlt12.gif"> <I>right</I>[<I>x</I>]</sub></sup></pre><P><pre>3  <B>return</B> <I>x</I></sub></sup></pre><P>Both of these procedures run in <I>O</I>(<I>h</I>) time on a tree of height <I>h,</I> since they trace paths downward in the tree.<P><P><h2>Successor and predecessor</h2><P><a name="07de_1497"><a name="07de_1498"><a name="07de_1499"><a name="07de_149a">Given a node in a binary search tree, it is sometimes important to be able to find its successor in the sorted order determined by an inorder tree walk. If all keys are distinct, the successor of a node <I>x</I> is the node with the smallest key greater than <I>key</I>[<I>x</I>]<I>.</I> The structure of a binary search tree allows us to determine the successor of a node without ever comparing keys. The following procedure returns the successor of a node <I>x</I> in a binary search tree if it exists, and <FONT FACE="Courier New" SIZE=2>NIL</FONT> if <I>x</I> has the largest key in the tree.<P><pre><a name="07de_149b">TREE SUCCESSOR(<I>x</I>)</sub></sup></pre><P><pre>1  <B>if</B> <I>right</I>[<I>x</I>] <IMG SRC="../IMAGES/noteq.gif"> NIL</sub></sup></pre><P><pre>2      <B>then return</B> TREE-MINIMUM(<I>right</I>[<I>x</I>])</sub></sup></pre><P><pre>3  <I>y </I><IMG SRC="../IMAGES/arrlt12.gif"> <I>p</I>[<I>x</I>]</sub></sup></pre><P><pre>4  <B>while</B> <I>y </I><IMG SRC="../IMAGES/noteq.gif"> NIL and <I>x</I> = <I>right</I>[<I>y</I>]</sub></sup></pre><P><pre>5       <B>do</B> <I>x </I><IMG SRC="../IMAGES/arrlt12.gif"> y</sub></sup></pre><P><pre>6          <I>y </I><IMG SRC="../IMAGES/arrlt12.gif"> <I>p</I>[<I>y</I>]</sub></sup></pre><P><pre>7  <B>return</B> <I>y</I></sub></sup></pre><P>The code for <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>SUCCESSOR</FONT> is broken into two cases. If the right subtree of node <I>x</I> is nonempty, then the successor of <I>x</I> is just the left-most node in the right subtree, which is found in line 2 by calling <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>MINIMUM</FONT>(<I>right</I>[<I>x</I>]). For example, the successor of the node with key 15 in Figure 13.2 is the node with key 17.<P>On the other hand, if the right subtree of node <I>x</I> is empty and <I>x</I> has a successor <I>y</I>, then <I>y</I> is the lowest ancestor of <I>x</I> whose left child is also an ancestor of <I>x</I>. In Figure 13.2, the successor of the node with key 13 is the node with key 15. To find <I>y</I>, we simply go up the tree from <I>x</I> until we encounter a<I> </I>node that is the left child of its parent; this is accomplished by lines 3-7 of <FONT FACE="Courier New" SIZE=2>TREE-</FONT><FONT FACE="Courier New" SIZE=2>SUCCESSOR</FONT>.<P><a name="07de_149c">The running time of <FONT FACE="Courier New" SIZE=2>TREE-</FONT><FONT FACE="Courier New" SIZE=2>SUCCESSOR</FONT> on a tree of height <I>h</I>is <I>O</I>(<I>h</I>), since we either follow a path up the tree or follow a path down the tree. The procedure <FONT FACE="Courier New" SIZE=2>TREE-</FONT><FONT FACE="Courier New" SIZE=2>PREDECESSOR</FONT>, which is symmetric to <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>SUCCESSOR</FONT>, also runs in time <I>O</I>(<I>h</I>).<P>In summary, we have proved the following theorem.<P><a name="07de_149d">Theorem 13.1<a name="07de_149d"><P>The dynamic-set operations <FONT FACE="Courier New" SIZE=2>SEARCH</FONT>, <FONT FACE="Courier New" SIZE=2>MINIMUM</FONT>, <FONT FACE="Courier New" SIZE=2>MAXIMUM</FONT>, <FONT FACE="Courier New" SIZE=2>SUCCESSOR</FONT>, and <FONT FACE="Courier New" SIZE=2>PREDECESSOR</FONT> can be made to run in <I>O</I>(<I>h</I>) time on a binary search tree of height <I>h</I>.      <P><P><h2><a name="07df_149e">Exercises<a name="07df_149e"></h2><P><a name="07df_149f">13.2-1<a name="07df_149f"><P>Suppose that we have numbers between 1 and 1000 in a binary search tree and want to search for the number 363. Which of the following sequences could <I>not</I> be the sequence of nodes examined?<P><I><B>a.</I>     </B>2, 252, 401, 398, 330, 344, 397, 363.<P><I><B>b.</I>     </B>924, 220, 911, 244, 898, 258, 362, 363.<P><I><B>c.</I>     </B>925, 202, 911, 240, 912, 245, 363.<P><I><B>d.</I>     </B>2, 399, 387, 219, 266, 382, 381, 278, 363.<P><I><B>e.</I>     </B>935, 278, 347, 621, 299, 392, 358, 363.<P><a name="07df_14a0">13.2-2<a name="07df_14a0"><P>Professor Bunyan thinks he has discovered a remarkable property of binary search trees. Suppose that the search for key <I>k </I>in a<I> </I>binary search tree ends up in a leaf. Consider three sets: <I>A</I>, the keys to the left of the search path; <I>B</I>, the keys on the search path; and <I>C</I>, the keys to the right of the search path. Professor Bunyan claims that any three keys <I>a</I> <IMG SRC="../IMAGES/memof12.gif"> <I>A</I>, <I>b</I> <IMG SRC="../IMAGES/memof12.gif"> <I>B</I>, and <I>c</I> <IMG SRC="../IMAGES/memof12.gif"> <I>C</I> must satisfy <I>a</I> <IMG SRC="../IMAGES/lteq12.gif"> <I>b</I> <IMG SRC="../IMAGES/lteq12.gif"> <I>c</I>. Give a smallest possible counterexample to the professor's claim.<P><a name="07df_14a1">13.2-3<a name="07df_14a1"><P>Use the binary-search-tree property to prove rigorously that the code for <FONT FACE="Courier New" SIZE=2>TREE-</FONT><FONT FACE="Courier New" SIZE=2>SUCCESSOR</FONT> is correct.<P><a name="07df_14a2">13.2-4<a name="07df_14a2"><P><a name="07df_149d">An inorder tree walk of an <I>n</I>-node binary search tree can be implemented by finding the minimum element in the tree with <FONT FACE="Courier New" SIZE=2>TREE-</FONT><FONT FACE="Courier New" SIZE=2>MINIMUM</FONT> and then making <I>n</I> - 1 calls to <FONT FACE="Courier New" SIZE=2>TREE-</FONT><FONT FACE="Courier New" SIZE=2>SUCCESSOR</FONT>. Prove that this algorithm runs in <IMG SRC="../IMAGES/bound.gif">(<I>n</I>) time.<P><a name="07df_14a3">13.2-5<a name="07df_14a3"><P>Prove that no matter what node we start at in a height-<I>h</I> binary search tree, <I>k</I> successive calls to <FONT FACE="Courier New" SIZE=2>TREE-</FONT><FONT FACE="Courier New" SIZE=2>SUCCESSOR</FONT> take <I>O</I>(<I>k</I> + <I>h</I>) time.<P><a name="07df_14a4">13.2-6<a name="07df_14a4"><P>Let <I>T</I> be a binary search tree, let <I>x</I> be a leaf node, and let <I>y</I> be its parent. Show that <I>key</I>[<I>y</I>] is either the smallest key in <I>T</I> larger than <I>key</I>[<I>x</I>] or the largest key in the tree smaller than <I>key</I>[<I>x</I>].<P><P><P><h1><a name="07e0_14a0">13.3 Insertion and deletion<a name="07e0_14a0"></h1><P><a name="07e0_149e"><a name="07e0_149f">The operations of insertion and deletion cause the dynamic set represented by a binary search tree to change. The data structure must be modified to reflect this change, but in such a way that the binary-search-tree property continues to hold. As we shall see, modifying the tree to insert a new element is relatively straightforward, but handling deletion is somewhat more intricate.<P><h2>Insertion</h2><P>To insert a new value <I>v</I> into a binary search tree <I>T</I>, we use the procedure <FONT FACE="Courier New" SIZE=2>TREE-</FONT><FONT FACE="Courier New" SIZE=2>INSERT</FONT>. The procedure is passed a node <I>z</I> for which <I>key</I>[<I>z</I>] = <I>v</I>, <I>left</I>[<I>z</I>] = <FONT FACE="Courier New" SIZE=2>NIL</FONT>, and <I>right</I>[<I>z</I>] = <FONT FACE="Courier New" SIZE=2>NIL</FONT>. It modifies <I>T</I> and some of the fields of <I>z</I> in such a way that <I>z</I> is inserted into an appropriate position in the tree.<P><pre><a name="07e1_14a0">TREE-INSERT(<I>T</I>,<I>z</I>)</sub></sup></pre><P><pre>1  <I>y</I> <IMG SRC="../IMAGES/arrlt12.gif"> NIL</sub></sup></pre><P><pre>2  <I>x</I> <IMG SRC="../IMAGES/arrlt12.gif"> <I>root</I>[<I>T</I>]</sub></sup></pre><P><pre>3  <B>while</B> <I>x</I> <IMG SRC="../IMAGES/noteq.gif"> NIL</sub></sup></pre><P><pre>4       <B>do</B> <I>y</I> <IMG SRC="../IMAGES/arrlt12.gif"> <I>x</I></sub></sup></pre><P><pre>5          <B>if</B> <I>key</I>[<I>z</I>] &lt; <I>key</I>[<I>x</I>]</sub></sup></pre><P><pre>6             <B>then</B> <I>x</I> <IMG SRC="../IMAGES/arrlt12.gif"> <I>left</I>[<I>x</I>]</sub></sup></pre><P><pre>7             <B>else</B> <I>x</I> <IMG SRC="../IMAGES/arrlt12.gif"> <I>right</I>[<I>x</I>]</sub></sup></pre><P><pre>8  <I>p</I>[<I>z</I>] <IMG SRC="../IMAGES/arrlt12.gif"> <I>y</I></sub></sup></pre><P><pre>9  <B>if</B> <I>y</I> = NIL</sub></sup></pre><P><pre>10      <B>then</B> <I>root</I>[<I>T</I>] <IMG SRC="../IMAGES/arrlt12.gif"> <I>z</I></sub></sup></pre><P><pre>11      <B>else if</B> <I>key</I>[<I>z</I>] &lt; <I>key</I>[<I>y</I>]</sub></sup></pre><P><pre>12              <B>then</B> <I>left</I>[<I>y</I>] <IMG SRC="../IMAGES/arrlt12.gif"> <I>z</I></sub></sup></pre><P><pre>13              <B>else</B> <I>right</I>[<I>y</I>] <IMG SRC="../IMAGES/arrlt12.gif"> <I>z</I></sub></sup></pre><P>Figure 13.3 shows how <FONT FACE="Courier New" SIZE=2>TREE-</FONT><FONT FACE="Courier New" SIZE=2>INSERT</FONT> works. Like the procedures <FONT FACE="Courier New" SIZE=2>TREE-</FONT><FONT FACE="Courier New" SIZE=2>SEARCH</FONT> and <FONT FACE="Courier New" SIZE=2>ITERATIVE</FONT>-<FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>SEARCH</FONT>, <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> begins at the root of the tree and traces a path downward. The pointer <I>x</I> traces the path, and the pointer <I>y</I> is maintained as the parent of <I>x</I>. After initialization, the <B>while</B> loop in lines 3-7 causes these two pointers to move down the tree, going left or right depending on the comparison of <I>key</I>[<I>z</I>] with <I>key</I>[<I>x</I>], until <I>x</I> is set to <FONT FACE="Courier New" SIZE=2>NIL</FONT>. This <FONT FACE="Courier New" SIZE=2>NIL</FONT> occupies the position where we wish to place the input item <I>z</I>. Lines 8-13 set the pointers that cause <I>z</I> to be inserted.<P>Like the other primitive operations on search trees, the procedure <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> runs in <I>O</I>(<I>h</I>) time on a tree of height <I>h</I>.<P><P><h2>Deletion</h2><P><a name="07e2_14a1"><a name="07e2_14a2">The procedure for deleting a given node <I>z</I> from a binary search tree takes as an argument a pointer to <I>z</I>. The procedure considers the three cases shown in Figure 13.4. If <I>z</I> has no children, we modify its parent <I>p</I>[<I>z</I>] to replace <I>z</I> with <FONT FACE="Courier New" SIZE=2>NIL</FONT> as its child. If the node has only a single child, we "splice out" <I>z</I> by making a new link between its child and its parent. Finally, if the node has two children, we splice out <I>z</I>'s successor <I>y</I>, which has no left child (see Exercise 13.3-4) and replace the contents of <I>z</I> with the contents of <I>y</I>.<P>The code for <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>DELETE</FONT> organizes these three cases a little differently.<P><img src="252_a.gif"><P><h4><a name="07e2_14a4">Figure 13.3 Inserting an item with key 13 into a binary search tree. Lightly shaded nodes indicate the path from the root down to the position where the item is inserted. The dashed line indicates the link in the tree that is added to insert the item.<a name="07e2_14a4"></sub></sup></h4><P><img src="252_b.gif"><P><h4><a name="07e2_14a5">Figure 13.4 Deleting a node z from a binary search tree. In each case, the node actually removed is lightly shaded. (a) If z has no children, we just remove it. (b) If z has only one child, we splice out z. (c) If z has two children, we splice out its successor y, which has at most one child, and then replace the contents of z with the contents of y.<a name="07e2_14a5"></sub></sup></h4><P><pre><a name="07e2_14a3">TREE-DELETE(<I>T, z</I>)</sub></sup></pre><P><pre>1  <B>if</B> <I>left</I>[<I>z</I>] = NIL or <I>right</I>[<I>z</I>] = NIL</sub></sup></pre><P><pre>2      <B>then</B> <I>y</I> <IMG SRC="../IMAGES/arrlt12.gif"> <I>z</I></sub></sup></pre><P><pre>3      <B>else</B> <I>y</I> <IMG SRC="../IMAGES/arrlt12.gif"> TREE-SUCCESSOR(<I>z</I>)</sub></sup></pre><P><pre>4  <B>if</B> <I>left</I>[<I>y</I>] <IMG SRC="../IMAGES/noteq.gif"> NIL</sub></sup></pre><P><pre>5      <B>then</B> <I>x</I> <IMG SRC="../IMAGES/arrlt12.gif"> <I>left</I>[<I>y</I>]</sub></sup></pre><P><pre>6      <B>else</B> <I>x</I> <IMG SRC="../IMAGES/arrlt12.gif"> <I>right</I>[<I>y</I>]</sub></sup></pre><P><pre>7  <B>if</B> <I>x</I> <IMG SRC="../IMAGES/noteq.gif"> NIL</sub></sup></pre><P><pre>8      <B>then</B> <I>p</I>[<I>x</I>] <IMG SRC="../IMAGES/arrlt12.gif"> <I>p</I>[<I>y</I>]</sub></sup></pre><P><pre>9  <B>if</B> <I>p</I>[<I>y</I>] = NIL</sub></sup></pre><P><pre>10      <B>then</B> <I>root</I>[<I>T</I>] <IMG SRC="../IMAGES/arrlt12.gif"> <I>x</I></sub></sup></pre><P><pre>11      <B>else if</B> <I>y</I> = <I>left</I>[<I>p</I>[<I>y</I>]]</sub></sup></pre><P><pre>12              <B>then</B> <I>left</I>[<I>p</I>[<I>y</I>]] <IMG SRC="../IMAGES/arrlt12.gif"> <I>x</I></sub></sup></pre><P><pre>13              <B>else</B> <I>right</I>[<I>p</I>[<I>y</I>]] <IMG SRC="../IMAGES/arrlt12.gif"> <I>x</I></sub></sup></pre><P><pre>14  <B>if</B> <I>y</I> <IMG SRC="../IMAGES/noteq.gif"> <I>z</I></sub></sup></pre><P><pre>15      <B>then</B> <I>key</I>[<I>z</I>] <IMG SRC="../IMAGES/arrlt12.gif"> <I>key</I>[<I>y</I>]</sub></sup></pre><P><pre>16           <img src="253_a.gif"> If <I>y</I> has other fields, copy them, too.</sub></sup></pre><P><pre>17  <B>return</B> <I>y</I></sub></sup></pre><P>In lines 1-3, the algorithm determines a node <I>y</I> to splice out. The node <I>y</I> is either the input node <I>z</I> (if <I>z</I> has at most 1 child) or the successor of <I>z</I> (if <I>z</I> has two children). Then, in lines 4-6, <I>x</I> is set to the non-<FONT FACE="Courier New" SIZE=2>NIL</FONT> child of <I>y</I>, or to <FONT FACE="Courier New" SIZE=2>NIL</FONT> if <I>y</I> has no children. The node <I>y</I> is spliced out in lines 7-13 by modifying pointers in <I>p</I>[<I>y</I>] and <I>x</I>. Splicing out <I>y</I> is somewhat complicated by the need for proper handling of the boundary conditions, which occur when <I>x</I> = <FONT FACE="Courier New" SIZE=2>NIL</FONT> or when <I>y</I> is the root. Finally, in lines 14-16, if the successor of <I>z</I> was the node spliced out, the contents of <I>z</I> are moved from <I>y</I> to <I>z</I>, overwriting the previous contents. The node <I>y</I> is returned in line 17 so that the calling procedure can recycle it via the free list. The procedure runs in <I>O</I>(<I>h</I>) time on a tree of height <I>h</I>.<P>In summary, we have proved the following theorem.<P><a name="07e2_14a6">Theorem 13.2<a name="07e2_14a6"><P>The dynamic-set operations <FONT FACE="Courier New" SIZE=2>INSERT</FONT> and <FONT FACE="Courier New" SIZE=2>DELETE</FONT> can be made to run in <I>O</I>(<I>h</I>) time on a binary search tree of height <I>h.     </I> <P><P><h2><a name="07e3_14a7">Exercises<a name="07e3_14a7"></h2><P><a name="07e3_14a8">13.3-1<a name="07e3_14a8"><P><a name="07e3_14a4">Give a recursive version of the <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> procedure.<P><a name="07e3_14a9">13.3-2<a name="07e3_14a9"><P>Suppose that a binary search tree is constructed by repeatedly inserting distinct values into the tree. Argue that the number of nodes examined in searching for a value in the tree is one plus the number of nodes examined when the value was first inserted into the tree.<P><a name="07e3_14aa">13.3-3<a name="07e3_14aa"><P><a name="07e3_14a5"><a name="07e3_14a6">We can sort a given set of <I>n</I> numbers by first building a binary search tree containing these numbers (using <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> repeatedly to insert the numbers one by one) and then printing the numbers by an inorder tree walk. What are the worst-case and best-case running times for this sorting algorithm?<P><a name="07e3_14ab">13.3-4<a name="07e3_14ab"><P>Show that if a node in a binary search tree has two children, then its successor has no left child and its predecessor has no right child.<P><a name="07e3_14ac">13.3-5<a name="07e3_14ac"><P>Suppose that another data structure contains a pointer to a node <I>y</I> in a binary search tree, and suppose that <I>y</I>'s predecessor <I>z</I> is deleted from the tree by the procedure <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>. What problem can arise? How can <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>DELETE</FONT> be rewritten to solve this problem?<P><a name="07e3_14ad">13.3-6<a name="07e3_14ad"><P>Is the operation of deletion "commutative" in the sense that deleting <I>x</I> and then <I>y</I> from a binary search tree leaves the same tree as deleting <I>y</I> and then <I>x</I>? Argue why it is or give a counterexample.<P><a name="07e3_14ae">13.3-7<a name="07e3_14ae"><P>When node <I>z</I> in <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>DELETE</FONT> has two children, we could splice out its predecessor rather than its successor. Some have argued that a fair strategy, giving equal priority to predecessor and successor, yields better empirical performance. How might <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>DELETE</FONT> be changed to implement such a fair strategy?<P><P><P><h1><a name="07e4_14ac">* 13.4 Randomly built binary search trees<a name="07e4_14ac"></h1><P><a name="07e4_14a7">We have shown that all the basic operations on a binary search tree run in <I>O</I>(<I>h</I>) time, where <I>h</I> is the height of the tree. The height of a binary search tree varies, however, as items are inserted and deleted. In order to analyze the behavior of binary search trees in practice, it is reasonable to make statistical assumptions about the distribution of keys and the sequence of insertions and deletions.<P><a name="07e4_14a8"><a name="07e4_14a9">Unfortunately, little is known about the average height of a binary search tree when both insertion and deletion are used to create it. When the tree is created by insertion alone, the analysis becomes more tractable. Let us therefore define a <I><B>randomly built binary search tree</I></B> on <I>n</I> distinct keys as one that arises from inserting the keys in random order into an initially empty tree, where each of the <I>n</I>! permutations of the input keys is equally likely. (Exercise 13.4-2 asks you to show that this notion is different from assuming that every binary search tree on <I>n</I> keys is equally likely.) The goal of this section is to show that the expected height of a randomly built binary search tree on <I>n</I> keys is <I>O</I>(lg <I>n</I>).<P>We begin by investigating the structure of binary search trees that are built by insertion alone.<P><a name="07e4_14ad">Lemma 13.3<a name="07e4_14ad"><P>Let <I>T</I> be the tree that results from inserting <I>n</I> distinct keys <I>k</I><SUB>1</SUB>,<I> k</I><SUB>2</SUB>, . . . ,<I> k<SUB>n</I></SUB> (in order) into an initially empty binary search tree. Then <I>k<SUB>i</I></SUB> is an ancestor of <I>k<SUB>j</I></SUB> in <I>T</I>, for l <IMG SRC="../IMAGES/lteq12.gif"> <I>i</I> &lt; <I>j</I> <IMG SRC="../IMAGES/lteq12.gif"> <I>n</I>, if and only if<P><pre><I>k<SUB>i</I></SUB> = min {<I>k<SUB>l</I></SUB> : 1 <IMG SRC="../IMAGES/lteq12.gif"> <I>l</I> <IMG SRC="../IMAGES/lteq12.gif"> <I>i</I> and <I>k<SUB>l</I></SUB> &gt; <I>k<SUB>j</I></SUB>}</sub></sup></pre><P>or<P><pre><I>k<SUB>i</I></SUB> = max {<I>k<SUB>l</I></SUB>: 1 <IMG SRC="../IMAGES/lteq12.gif"> <I>l</I> <IMG SRC="../IMAGES/lteq12.gif"> <I>i</I> and <I>k<SUB>l</I></SUB> &lt; <I>k<SUB>j</I></SUB>} .</sub></sup></pre><P><I><B>Proof     </I></B><IMG SRC="../IMAGES/rtbigar.gif">: Suppose that <I>k<SUB>i</I></SUB> is an ancestor of <I>k<SUB>j</I></SUB>. Consider the tree <I>T<SUB>i</I></SUB> that results after the keys <I>k</I><SUB>1</SUB>, <I>k</I><SUB>2</SUB>, . . . , <I>k<SUB>i</I></SUB> have been inserted. The path in <I>T<SUB>i </I></SUB>from the root to <I>k<SUB>i</I></SUB> is the same as the path in <I>T</I> from the root to <I>k<SUB>i</I></SUB>. Thus, if <I>k<SUB>j</I></SUB> were inserted into <I>T<SUB>i</I></SUB>, it would become either the left or the right child of <I>k<SUB>i</I></SUB>. Consequently (see Exercise 13.2-6), <I>k<SUB>i</I></SUB> is either the smallest key among <I>k</I><SUB>1</SUB>, <I>k</I><SUB>2</SUB>, . . . , <I>k<SUB>i</I></SUB> that is larger than <I>k<SUB>j</I></SUB> or the largest key among <I>k</I><SUB>1</SUB>, <I>k</I><SUB>2</SUB>, . . . , <I>k<SUB>i</I></SUB> that is smaller than <I>k<SUB>j</I></SUB>.<P><IMG SRC="../IMAGES/lftbigar.gif">: Suppose that <I>k<SUB>i</I></SUB> is the smallest key among <I>k</I><SUB>1</SUB>, <I>k</I><SUB>2</SUB>, . . . , <I>k<SUB>i</I></SUB> that is larger than <I>k<SUB>j</I></SUB>. (The case in which <I>k<SUB>i</I></SUB> is the largest key among <I>k</I><SUB>1</SUB>,<SUB> </SUB><I>k</I><SUB>2</SUB>, . . . , <I>k<SUB>i</I></SUB> that is smaller than <I>k<SUB>j</I></SUB> is handled symmetrically.) Comparing <I>k<SUB>j</I></SUB> to any of the keys on the path in <I>T</I> from the root to <I>k<SUB>i</I></SUB> yields the same results as comparing <I>k<SUB>i</I></SUB> to the keys. Hence, when <I>k<SUB>j</I></SUB> is inserted, it follows a path through <I>k<SUB>i</I></SUB> and is inserted as a descendant of <I>k<SUB>i</I></SUB>.      <P>As a corollary of Lemma 13.3, we can precisely characterize the depth of a key based on the input permutation.<P><a name="07e4_14ae">Corollary 13.4<a name="07e4_14ae"><P>Let <I>T</I> be the tree that results from inserting <I>n</I> distinct keys <I>k</I><SUB>1</SUB>, <I>k</I><SUB>2</SUB>, . . . , <I>k<SUB>n</I></SUB> (in order) into an initially empty binary search tree. For a given key <I>k<SUB>j</I></SUB>, where 1 <IMG SRC="../IMAGES/lteq12.gif"> <I>j</I> <IMG SRC="../IMAGES/lteq12.gif"> <I>n</I>, define<P><pre><I>G<SUB>j</I></SUB> = {<I>k<SUB>i</I></SUB> : 1 <IMG SRC="../IMAGES/lteq12.gif"> <I>i</I> &lt; <I>j</I> and <I>k<SUB>l</I></SUB> &gt; <I>k<SUB>i</I></SUB> &gt; <I>k<SUB>j</I></SUB> for all <I>l</I> &lt; <I>i</I> such that <I>k<SUB>l</I></SUB> &gt; <I>k<SUB>j</I></SUB>}</sub></sup></pre><P>and<P><pre><I>L<SUB>j</I></SUB> = {<I>k<SUB>i</I></SUB> : 1 <IMG SRC="../IMAGES/lteq12.gif"> <I>i</I> &lt; <I>j</I> and <I>k<SUB>l</I></SUB> &lt; <I>k<SUB>i</I></SUB> &lt; <I>k<SUB>j</I></SUB> for all <I>l</I> &lt; <I>i</I> such that <I>k<SUB>l</I></SUB> &lt; <I>k<SUB>j</I></SUB>} .</sub></sup></pre><P>Then the keys on the path from the root to <I>k<SUB>j</I></SUB> are exactly the keys in <I>G<SUB>j</I></SUB> <FONT FACE="Times New Roman" SIZE=3><IMG SRC="../IMAGES/wideu.gif"></FONT> <I>L<SUB>j</I></SUB>, and the depth in <I>T</I> of any key <I>k<SUB>j</I></SUB> is<P><pre><I>d</I>(<I>k<SUB>j</I></SUB>, <I>T</I>) = |<I>G<SUB>j</SUB>| + |</I>L<SUB>j<I></SUB>| .                                                    </I></sub></sup></pre><P>Figure 13.5 illustrates the two sets <I>G<SUB>j</I></SUB> and <I>L<SUB>j</I></SUB>. The set <I>G<SUB>j</I></SUB> contains any key <I>k<SUB>i</I></SUB> inserted before <I>k<SUB>j</I></SUB> such that <I>k<SUB>i</I></SUB> is the smallest key among <I>k</I><SUB>1</SUB>, <I>k</I><SUB>2</SUB>, . . . , <I>k<SUB>i</I></SUB> that is larger than <I>k<SUB>j</I></SUB>. (The structure of <I>L<SUB>j</I></SUB> is symmetric.) To better understand the set <I>G<SUB>j</I></SUB>, let us explore a method by which we can enumerate its elements. Among the keys <I>k</I><SUB>1</SUB>, <I>k</I><SUB>2</SUB>, . . . , <I>k<SUB>j</I></SUB>-<SUB>1</SUB>, consider in order those that are larger than <I>k<SUB>j</I></SUB>. These keys are shown as <I>G</I>'<I><SUB>j</I></SUB>, in the figure. As each key is considered in turn, keep a running account of the minimum. The set <I>G<SUB>j</I></SUB> consists of those elements that update the running minimum.<P>Let us simplify this scenario somewhat for the purpose of analysis. Suppose that <I>n</I> distinct numbers are inserted one at a time into a dynamic set. If all permutations of the numbers are equally likely, how many times on average does the minimum of the set change? To answer this question, suppose that the <I>i</I>th number inserted is <I>k<SUB>i</I></SUB>, for <I>i</I> = 1, 2, . . . , <I>n</I>. The probability is l/<I>i</I> that <I>k<SUB>i</I></SUB> is the minimum of the first <I>i</I> numbers, since the rank of <I>k<SUB>i</I></SUB> among the first <I>i</I> numbers is equally likely to be any of the <I>i</I> possible ranks. Consequently, the expected number of changes to the minimum of the set is<P><img src="256_a.gif"><P>where <I>H<SUB>n</I></SUB> = ln <I>n</I> + <I>O</I>(1) is the <I>n</I>th harmonic number (see equation (3.5) and Problem 6-2).<P>We therefore expect the number of changes to the minimum to be approximately ln <I>n</I>, and the following lemma shows that the probability that it is much greater is very small.<P><a name="07e4_14af">Lemma 13.5<a name="07e4_14af"><P>Let <I>k</I><SUB>1</SUB>, <I>k</I><SUB>2</SUB>, . . . , <I>k<SUB>n</I></SUB> be a random permutation of <I>n</I> distinct numbers, and let |<I>S</I>| be the random variable that is the cardinality of the set<P><pre><I>S</I> = {<I>k<SUB>i</I></SUB> : 1 <IMG SRC="../IMAGES/lteq12.gif"> <I>i</I> <IMG SRC="../IMAGES/lteq12.gif"> <I>n</I> and <I>k<SUB>l</I></SUB> &gt; <I>k<SUB>i</SUB> </I>for all <I>l</I> &lt; <I>i</I>} .</sub></sup></pre><P><h4><a name="07e4_14b0">(13.1)<a name="07e4_14b0"></sub></sup></h4><P>Then Pr{|<I>S</I>| <IMG SRC="../IMAGES/gteq.gif"> (<IMG SRC="../IMAGES/beta14.gif"><I> + 1)</I>H<SUB>n<I></SUB>} <IMG SRC="../IMAGES/lteq12.gif"> 1/</I>n<I><SUP>2</SUP>, where </I>H<SUB>n<I></SUB> is the </I>n<I>th harmonic number and <IMG SRC="../IMAGES/beta14.gif"></I> <IMG SRC="../IMAGES/approx18.gif"> 4.32 satisfies the equation (ln <IMG SRC="../IMAGES/beta14.gif"><I> - 1) <IMG SRC="../IMAGES/beta14.gif"></I> = 2.<P><a name="07e4_14aa"><I><B>Proof     </I></B>We can view the cardinality of the set <I>S</I> as being determined by <I>n</I> Bernoulli trials, where a success occurs in the <I>i</I>th trial when <I>k<SUB>i</I></SUB> is smaller than the elements <I>k</I><SUB>1</SUB>, <I>k</I><SUB>2</SUB>, . . . , <I>k<SUB>i</I></SUB>-<SUB>l</SUB>. Success in the <I>i</I>th trial occurs with probability 1/<I>i</I>. The trials are independent, since the probability that <I>k<SUB>i</I></SUB> is the minimum of <I>k</I><SUB>1</SUB>, <I>k</I><SUB>2</SUB>, . . . , <I>k<SUB>i</I></SUB> is independent of the relative ordering of <I>k</I><SUB>1</SUB>, <I>k</I><SUB>2</SUB>, . . . , <I>k<SUB>i</I></SUB>-<SUB>1</SUB>.<P>We can use Theorem 6.6 to bound the probability that |<I>S</I>| <IMG SRC="../IMAGES/gteq.gif"> (<IMG SRC="../IMAGES/beta14.gif"><I></I> + 1 )<I>H<SUB>n</I></SUB> . The expectation of |<I>S</I>| is <IMG SRC="../IMAGES/mu12.gif"><I></I> = <I>H<SUB>n</I></SUB> <IMG SRC="../IMAGES/gteq.gif"> ln <I>n</I>. Since <IMG SRC="../IMAGES/beta14.gif"><I></I> &gt; 1, Theorem 6.6 yields<P><img src="257_a.gif"><P><h4><a name="07e4_14b1">Figure 13.5 Illustrating the two sets G<SUB>j</SUB> and L<SUB>j </SUB>that comprise the keys on a path from the root of a binary search tree to a key k<SUB>j = </SUB>17. (a) The nodes with keys in G<sub>j</sub> are black, and the nodes with keys in L<SUB>j</SUB> are white. All other nodes are shaded. The path from the root down to the node with key k<SUB>j</SUB> is shaded. Keys to the left of the dashed line are less than k<SUB>j</SUB>, and keys to the right are greater. The tree is constructed by inserting the keys shown in the topmost list in (b). The set G'<SUB>j</SUB> = {21, 25, 19, 29}consists of those elements that are inserted before 17 and are greater than 17. The set G<SUB>j</SUB> = {21, 19} consists of those elements that update a running minimum of the elements in G'<SUB>j</SUB>. Thus, the key 21 is in G<SUB>j</SUB>, since it is the first element. The key 25 is not in G<SUB>j</SUB>, since it is larger than the running minimum 21. The key 19 is in G<SUB>j,</SUB> since it is smaller than the running minimum 21. The key 29 is not in G<SUB>j</SUB>, since it is larger than the running minimum 19. The structures of L'<SUB>j</SUB> and L<SUB>j</SUB> are symmetric.<a name="07e4_14b1"></sub></sup></h4><P><img src="258_a.gif"><P>which follows from the definition of <IMG SRC="../IMAGES/beta14.gif"><I>.      </I><P><a name="07e4_14ab">We now have the tools to bound the height of a randomly built binary search tree.<P><a name="07e4_14b2">Theorem 13.6<a name="07e4_14b2"><P>The average height of a randomly built binary search tree on <I>n</I> distinct keys is <I>O</I>(lg <I>n</I>).<P><I><B>Proof     </I></B>Let <I>k</I><SUB>1</SUB>, <I>k</I><SUB>2</SUB>, . . . , <I>k<SUB>n</I></SUB> be a random permutation on the <I>n</I> keys, and let <I>T</I> be the binary search tree that results from inserting the keys in order into an initially empty tree. We first consider the probability that the depth <I>d(k<SUB>j</SUB>, T)</I> of a given key <I>k<SUB>j</I></SUB> is at least <I>t</I>, for an arbitrary value <I>t.</I> By the characterization of <I>d</I> (<I>k<SUB>j</SUB>, T</I>) in Corollary 13.4, if the depth of <I>k<SUB>j</I></SUB> is at least <I>t</I>, then the cardinality of one of the two sets <I>G<SUB>j</I></SUB> and <I>L<SUB>j</I></SUB> must be at least <I>t/</I>2. Thus,<P><pre>Pr{<I>d</I>(<I>k<SUB>j</I></SUB>,<I> T</I>)<I> </I><IMG SRC="../IMAGES/gteq.gif"> <I>t</I>} <IMG SRC="../IMAGES/lteq12.gif"> Pr{|<I>G<SUB>j</I></SUB>| <IMG SRC="../IMAGES/gteq.gif"> <I>t</I>/2} + Pr{|<I>L<SUB>j</I></SUB>| <IMG SRC="../IMAGES/gteq.gif"> <I>t</I>/2} .</sub></sup></pre><P><h4><a name="07e4_14b3">(13.2)<a name="07e4_14b3"></sub></sup></h4><P>Let us examine Pr{|<I>G<SUB>j</SUB></I>|<SUB><IMG SRC="../IMAGES/gteq.gif"></SUB><I>t</I>/2} first. We have<P><pre>Pr{|<I>Gj</I>|<I> </I><IMG SRC="../IMAGES/gteq.gif"> <I>t</I>/2}</sub></sup></pre><P><pre>= Pr{|{k<I><SUB>i</I></SUB>: 1 <IMG SRC="../IMAGES/lteq12.gif"> <I>i</I> &lt; <I>j</I> and <I>k<SUB>l</I></SUB> &gt; <I>k<SUB>i</I></SUB> &gt; <I>k<SUB>j</I></SUB> for all <I>l</I> &lt; <I>i</I>}| <IMG SRC="../IMAGES/gteq.gif"> <I>t</I>/2}</sub></sup></pre><P><pre><IMG SRC="../IMAGES/lteq12.gif"> Pr{|{<I>k<SUB>i</I></SUB>: <I>i </I><IMG SRC="../IMAGES/lteq12.gif"><I> n</I> and <I>k<SUB>i</I></SUB> &gt; k<I>i</I> for all <I>l </I>&gt;<I> i</I>}| <IMG SRC="../IMAGES/gteq.gif"> <I>t</I>/2}</sub></sup></pre><P><pre>= Pr{|<I>S</I>| <I><IMG SRC="../IMAGES/gteq.gif"></I> t<I>/2} ,</I></sub></sup></pre><P>where <I>S</I> is defined as in equation (13.1). To justify this argument, note that the probability does not decrease if we extend the range of <I>i</I> from <I>i</I> &lt; <I>j</I> to <I>i</I> <IMG SRC="../IMAGES/lteq12.gif"> <I>n</I>, since more elements are added to the set. Likewise, the probability does not decrease if we remove the condition that <I>k<SUB>i</I></SUB> &gt; <I>k<SUB>j</I></SUB>, since we are substituting a random permutation on possibly fewer than <I>n </I>elements (those <I>k<SUB>i</I></SUB> that are greater than <I>k<SUB>j</I></SUB>) for a random permutation on <I>n</I> elements.<P>Using a symmetric argument, we can prove that<P><pre>Pr{|<I>L<SUB>j</I></SUB>|<SUB> </SUB><IMG SRC="../IMAGES/gteq.gif"> <SUB><I>t</I>/2} <IMG SRC="../IMAGES/lteq12.gif"> Pr{|<I>S</I>| <IMG SRC="../IMAGES/gteq.gif"> <I>t</I>/2},</sub></sup></pre><P>and thus, by inequality (13.2), we obtain<P><pre>Pr {<I>d </I>(<I>k<SUB>j</SUB>, T</I>) <IMG SRC="../IMAGES/gteq.gif"> <I>t</I>} <IMG SRC="../IMAGES/lteq12.gif"> 2 Pr{|<I>S</I>| <IMG SRC="../IMAGES/gteq.gif"> <I>t</I>/2} .</sub></sup></pre><P>If we choose <I>t</I> = 2(<IMG SRC="../IMAGES/beta14.gif"><I></I> + 1)<I>H<SUB>n</I></SUB>, where <I>H<SUB>n</I></SUB> is the <I>n</I>th harmonic number and <IMG SRC="../IMAGES/beta14.gif"><I></I> <IMG SRC="../IMAGES/approx18.gif"> 4.32 satisfies (1n <IMG SRC="../IMAGES/beta14.gif"><I></I> - l)<IMG SRC="../IMAGES/beta14.gif"><I></I> = 2, we can apply Lemma 13.5 to conclude that<P><pre>Pr{<I>d</I>(<I>k<SUB>j</SUB>, T</I>) <IMG SRC="../IMAGES/gteq.gif"> 2(<IMG SRC="../IMAGES/beta14.gif"><I> + 1)</I>H<SUB>n<I></SUB>}  <IMG SRC="../IMAGES/lteq12.gif">  2Pr{|</I>S<I>| <IMG SRC="../IMAGES/gteq.gif"> (<IMG SRC="../IMAGES/beta14.gif"></I> + 1)<I>H<SUB>n</I></SUB>}</sub></sup></pre><P><pre><IMG SRC="../IMAGES/lteq12.gif">  2/<I>n</I><SUP>2 </SUP>.</sub></sup></pre><P>Since there are at most <I>n</I> nodes in a randomly built binary search tree, the probability that <I>any</I> node's depth is at least 2(<IMG SRC="../IMAGES/beta14.gif"><I></I> + 1 )<I>H<SUB>n</I></SUB> is therefore, by Boole's inequality (6.22), at most <I>n(</I>2<I>/n</I><SUP>2</SUP><I>)</I> = 2/<I>n</I>. Thus, at least 1 - 2/<I>n </I>of the time, the height of a randomly built binary search tree is less than 2(<IMG SRC="../IMAGES/beta14.gif"><I></I> + 1)<I>H<SUB>n</I></SUB>, and at most 2/<I>n</I> of the time, it is at most <I>n</I>. The expected height is therefore at most (2(<IMG SRC="../IMAGES/beta14.gif"><I></I> + 1)<I>H<SUB>n</I></SUB>)(l - 2/<I>n</I>) + <I>n</I>(2/<I>n</I>) = <I>O(lg n)</I>.      <P><h2><a name="07e5_14ae">Exercises<a name="07e5_14ae"></h2><P><a name="07e5_14af">13.4-1<a name="07e5_14af"><P>Describe a binary search tree on <I>n</I> nodes such that the average depth of a node in the tree is <IMG SRC="../IMAGES/bound.gif">(lg <I>n</I>) but the height of the tree is <I>w</I>(lg <I>n</I>). How large can the height of an <I>n</I>-node binary search tree be if the average depth of a node is <IMG SRC="../IMAGES/bound.gif">(lg <I>n</I>)?<P><a name="07e5_14b0">13.4-2<a name="07e5_14b0"><P>Show that the notion of a randomly chosen binary search tree on <I>n</I> keys, where each binary search tree of <I>n</I> keys is equally likely to be chosen, is different from the notion of a randomly built binary search tree given in this section. (<I>Hint:</I> List the possibilities when <I>n</I> = 3.)<P><a name="07e5_14b1">13.4-3<a name="07e5_14b1"><P>Given a constant <I>r</I> <IMG SRC="../IMAGES/gteq.gif"> 1, determine <I>t</I> such that the probability is less than 1 /<I>n<SUP>r</I></SUP> that the height of a randomly built binary search tree is at least <I>tH<SUB>n</I></SUB>.<P><a name="07e5_14b2">13.4-4<a name="07e5_14b2"><P><a name="07e5_14ac"><a name="07e5_14ad">Consider <FONT FACE="Courier New" SIZE=2>RANDOMIZED</FONT>-<FONT FACE="Courier New" SIZE=2>QUICKSORT</FONT> operating on a sequence of <I>n</I> input numbers. Prove that for any constant <I>k</I> &gt; 0, all but <I>O</I>(l/<I>n<SUP>k</I></SUP>) of the <I>n</I>! input permutations yield an <I>O</I>(<I>n</I>1g <I>n</I>) running time.<P><P><P><h1><a name="07e6_14be">Problems<a name="07e6_14be"></h1><P><a name="07e6_14bf">13-1     Binary search trees with equal keys<a name="07e6_14bf"><P><a name="07e6_14ae"><a name="07e6_14af"><a name="07e6_14b0">Equal keys pose a problem for the implementation of binary search trees.<P><I><B>a</I>.</B>     What is the asymptotic performance of <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> when used to insert <I>n</I> items with identical keys into an initially empty binary search tree?<P>We propose to improve <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> by testing before line 5 whether or not <I>key</I>[<I>z</I>] = <I>key</I>[<I>x</I>] and by testing before line 11 whether or not <I>key</I>[<I>z</I>] =<I> key</I>[<I>y</I>]. If equality holds, we implement one of the following strategies. For each strategy, find the asymptotic performance of inserting <I>n</I> items with identical keys into an initially empty binary search tree. (The strategies are described for line 5, in which we compare the keys of <I>z</I> and <I>x</I>. Substitute<I> y</I> for <I>x</I> to arrive at the strategies for line 11.)<P><I><B>b</I>.</B>     Keep a Boolean flag <I>b</I>[<I>x</I>] at node <I>x</I>, and set <I>x</I> to either <I>left</I>[<I>x</I>] or <I>right</I>[<I>x</I>]based on the value of <I>b</I>[<I>x</I>], which alternates between <FONT FACE="Courier New" SIZE=2>FALSE</FONT> and <FONT FACE="Courier New" SIZE=2>TRUE</FONT> each time the node is visited during <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>INSERT</FONT>.<P><I><B>c.</I>     </B>Keep a list of nodes with equal keys at <I>x</I>, and insert <I>z</I> into the list.<P><I><B>d</I>.</B>     Randomly set <I>x</I> to either <I>left</I>[<I>x</I>] or <I>right</I>[<I>x</I>]. (Give the worst-case performance and informally derive the average-case performance.)<P><a name="07e6_14c0">13-2     Radix trees<a name="07e6_14c0"><P><a name="07e6_14b1"><a name="07e6_14b2"><a name="07e6_14b3"><a name="07e6_14b4"><a name="07e6_14b5">Given two strings <I>a</I> = <I>a<SUB>0</SUB>a</I><SUB>1</SUB>. . .<I>a<SUB>p</I></SUB> and <I>b</I> = <I>b</I><SUB>0</SUB><I>b</I><SUB>1</SUB><I>. . .bq</I>,<I> where each a<SUB>i</I></SUB> and each <I>b<SUB>j</I></SUB> is in some ordered set of characters, we say that string <I>a </I>is<I> <B>lexicographically less than</I></B> string <I>b</I> if either<P>1.     there exists an integer <I>j</I>, 0 <IMG SRC="../IMAGES/lteq12.gif"> <I>j</I> <IMG SRC="../IMAGES/lteq12.gif"> min(<I>p, q</I>), such that <I>a<SUB>i</I></SUB> = <I>b<SUB>i</I></SUB> for all<I> i = </I>0, 1<I>, . . . , j</I> - 1 and <I>a<SUB>j</I></SUB> &lt; <I>b<SUB>j</I></SUB>, or<P>2.<I>     p&lt;q</I> and <I>a<SUB>i </I></SUB>= <I>b<SUB>i</I></SUB> for all <I>i </I>= 0, l, . . . , <I>p</I>.<P>For example, if <I>a</I> and <I>b</I> are bit strings, then 10100 &lt; 10110 by rule 1(letting <I>j</I> = 3) and 10100 &lt; 101000 by rule 2. This is similar to the ordering used in English-language dictionaries.<P>The <I><B>radix tree</I></B> data structure shown in Figure 13.6 stores the bit strings 1011, 10, 011, 100, and 0. When searching for a key <I>a</I> = <I>a</I><SUB>0</SUB><I>a</I><SUB>1</SUB> . . . <I>a<SUB>p</I></SUB>, we go left at a node of depth <I>i</I> if <I>a<SUB>i</I></SUB> = 0 and right if <I>a<SUB>i</I></SUB> = 1. Let <I>S</I> be a set of distinct binary strings whose lengths sum to <I>n</I>. Show how to use a radix tree to sort <I>S</I> lexicographically in <IMG SRC="../IMAGES/bound.gif">(<I>n</I>) time. For the example in Figure 13.6, the output of the sort should be the sequence 0, 011, 10, 100, 1011.<P><a name="07e6_14c1">13-3     Average node depth in a randomly built binary search tree<a name="07e6_14c1"><P><a name="07e6_14b6"><a name="07e6_14b7"><a name="07e6_14b8"><a name="07e6_14b9"><a name="07e6_14ba">In this problem, we prove that the average depth of a node in a randomly built binary search tree with <I>n</I> nodes is <I>O(</I>lg <I>n)</I>. Although this result is weaker than that of Theorem 13.6, the technique we shall use reveals a surprising similarity between the building of a binary search tree and the running of <FONT FACE="Courier New" SIZE=2>RANDOMIZED</FONT>-<FONT FACE="Courier New" SIZE=2>QUICKSORT</FONT> from Section 8.3.<P>We start by recalling from Chapter 5 that the internal path length <I>P</I>(<I>T</I>)of a binary tree <I>T</I> is the sum, over all nodes <I>x</I> in <I>T</I>, of the depth of node <I>x</I>, which we denote by <I>d </I>(<I>x, T</I>).<P><img src="261_a.gif"><P><h4><a name="07e6_14c2">Figure 13.6 A radix tree storing the bit strings l011, 10, 011, 100, and 0. Each node's key can be determined by traversing the path from the root to that node. There is no need, therefore, to store the keys in the nodes; the keys are shown here for illustrative purposes only. Nodes are heavily shaded if the keys corresponding to them are not in the tree; such nodes are present only to establish a path to other nodes.<a name="07e6_14c2"></sub></sup></h4><P><I><B>a.</I></B>     Argue that the average depth of a node in <I>T</I> is<P><img src="261_b.gif"><P>Thus, we wish to show that the expected value of <I>P</I>(<I>T</I>) is <I>O</I>(<I>n </I>1g<I> n</I>).<P><I><B>b.</I>     </B>Let <I>T<SUB>L</I></SUB> and <I>T<SUB>R</I></SUB> denote the left and right subtrees of tree <I>T</I>, respectively. Argue that if <I>T</I> has <I>n</I> nodes, then<P><pre><I>P</I>(<I>T</I>) = <I>P</I>(<I>T<SUB>L</I></SUB>) + <I>P</I>(<I>T<SUB>R</I></SUB>) + <I>n</I> - 1 .</sub></sup></pre><P><I><B>c.</I>     </B>Let <I>P</I>(<I>n</I>) denote the average internal path length of a randomly built binary search tree with <I>n</I> nodes. Show that<P><img src="261_c.gif"><P><I><B>d.     </I></B>Show that <I>P</I>(<I>n</I>) can be rewritten as<P><img src="261_d.gif"><P><I><B>e.     </I></B>Recalling the analysis of the randomized version of quicksort, conclude that <I>P</I>(<I>n</I>) = <I>O</I>(<I>n </I>lg <I>n</I>).<P>At each recursive invocation of quicksort, we choose a random pivot element to partition the set of elements being sorted. Each node of a binary search tree partitions the set of elements that fall into the subtree rooted at that node.<P><I><B>f.</I>     </B>Describe an implementation of quicksort in which the comparisons to sort a set of elements are exactly the same as the comparisons to insert the elements into a binary search tree. (The order in which comparisons are made may differ, but the same comparisons must be made.)<P><a name="07e6_14c3">13-4     Number of different binary trees<a name="07e6_14c3"><P><a name="07e6_14bb">Let <I>b<SUB>n</I></SUB> denote the number of different binary trees with <I>n</I> nodes. In this problem, you will find a formula for <I>b<SUB>n</I></SUB> as well as an asymptotic estimate.<P><I><B>a.     </I></B>Show that <I>b</I><SUB>0</SUB> = 1 and that, for <I>n</I> <IMG SRC="../IMAGES/gteq.gif"> 1,<P><img src="262_a.gif"><P><I><B>b     </I></B>Let <I>B</I>(<I>x</I>) be the generating function<P><img src="262_b.gif"><P>(see Problem 4-6 for the definition of generating functions). Show that <I>B</I>(<I>x</I>) = <I>xB</I>(<I>x</I>)<SUP>2</SUP> + 1 and hence<P><img src="262_c.gif"><P><a name="07e6_14bc">The <I><B>Taylor expansion</I></B> of <I>f</I>(<I>x</I>) around the point <I>x</I> = <I>a</I> is given by<P><img src="262_d.gif"><P>where<SUB> </SUB><I>f</I><SUP>(<I>k</I>)</SUP> (<I>x</I>) is the <I>k</I>th derivative of <I>f</I> evaluated at <I>x</I>.<P><I><B>c.</I>     </B>Show that<P><img src="262_e.gif"><P><a name="07e6_14bd">(the <I>n</I>th <I><B>Catalan number</I></B>) by using the Taylor expansion of <img src="262_f.gif"> around <I>x</I> = 0. (If you wish,<SUB> </SUB>instead of using the Taylor expansion, you may use the generalization of the binomial expansion (6.5) to<SUB> </SUB>non-integral exponents <I>n</I>, where for any real number <I>n</I> and integer <I>k</I>, we interpret <img src="262_g.gif"> to be <I>n</I>(<I>n</I> - 1) . . . (<I>n</I> - <I>k</I> + 1)/<I>k</I>! if <I>k</I> <IMG SRC="../IMAGES/gteq.gif"> 0, and 0 otherwise.)<P><I><B>d.</I>     </B>Show that<P><img src="262_h.gif"><P><P><h1>Chapter notes</h1><P>Knuth [123] contains a good discussion of simple binary search trees as well as many variations. Binary search trees seem to have been independently discovered by a number of people in the late 1950's.<P><P><P><P><center>Go to <a href="chap14.htm">Chapter 14</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Back to <a href="toc.htm">Table of Contents</A></P></center></BODY></HTML>