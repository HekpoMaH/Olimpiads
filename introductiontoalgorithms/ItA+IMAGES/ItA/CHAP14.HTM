<HTML><HEAD><TITLE>Intro to Algorithms: CHAPTER 14: RED-BLACK TREES</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><a href="chap15.htm"><img align=right src="../../images/next.gif" alt="Next Chapter" border=0></A><a href="toc.htm"><img align=right src="../../images/toc.gif" alt="Return to Table of Contents" border=0></A><a href="chap13.htm"><img align=right src="../../images/prev.gif" alt="Previous Chapter" border=0></A><h1><a name="07e8_14bf">CHAPTER 14: RED-BLACK TREES<a name="07e8_14bf"></h1><P><a name="07e8_14be">Chapter 13 showed that a binary search tree of height <I>h</I> can implement any of the basic dynamic-set operations--such as <FONT FACE="Courier New" SIZE=2>SEARCH</FONT>, <FONT FACE="Courier New" SIZE=2>PREDECESSOR</FONT>, <FONT FACE="Courier New" SIZE=2>SUCCESSOR</FONT>, <FONT FACE="Courier New" SIZE=2>MINIMUM</FONT>, <FONT FACE="Courier New" SIZE=2>MAXIMUM</FONT>, <FONT FACE="Courier New" SIZE=2>INSERT</FONT>, and <FONT FACE="Courier New" SIZE=2>DELETE</FONT>--in <I>O</I>(<I>h</I>) time. Thus, the set operations are fast if the height of the search tree is small; but if its height is large, their performance may be no better than with a linked list. Red-black trees are one of many search-tree schemes that are "balance" in order to guarantee that basic dynamic-set operations take <I>O</I>(lg <I>n</I>) time in the worst case.<P><h1><a name="07ea_14d2">14.1 Properties of red-black trees<a name="07ea_14d2"></h1><P><a name="07ea_14bf"><a name="07ea_14c0"><a name="07ea_14c1"><a name="07ea_14c2"><a name="07ea_14c3">A <I><B>red-black tree</I></B> is a binary search tree with one extra bit of storage per node: its <I><B>color</I></B>, which can be either <FONT FACE="Courier New" SIZE=2>RED</FONT> or <FONT FACE="Courier New" SIZE=2>BLACK</FONT>. By constraining the way nodes can be colored on any path from the root to a leaf, red-black trees ensure that no such path is more than twice as long as any other, so that the tree is approximately <I><B>balanced.</I></B><P>Each node of the tree now contains the fields <I>color, key, left, right</I>, and <I>p.</I> If a child or the parent of a node does not exist, the corresponding pointer field of the node contains the value <FONT FACE="Courier New" SIZE=2>NIL</FONT>. We shall regard these <FONT FACE="Courier New" SIZE=2>NIL'S</FONT> as being pointers to external nodes (leaves) of the binary search tree and the normal, key-bearing nodes as being internal nodes of the tree.<P>A binary search tree is a red-black tree if it satisfies the following <I><B>red-black properties:</I></B><P>1.     Every node is either red or black.<P>2.     Every leaf (<FONT FACE="Courier New" SIZE=2>NIL</FONT>) is black.<P>3.     If a node is red, then both its children are black.<P>4.     Every simple path from a node to a descendant leaf contains the same number of black nodes.<P>An example of a red-black tree is shown in Figure 14.1.<P><a name="07ea_14c4"><a name="07ea_14c5"><a name="07ea_14c6"><a name="07ea_14c7">We call the number of black nodes on any path from, but not including, a node <I>x</I> to a leaf the <I><B>black-height</I></B> of the node, denoted bh(<I>x</I>). By property 4, the notion of black-height is well defined, since all descending paths from the node have the same number of black nodes. We define the black-height of a red-black tree to be the black-height of its root.<P><img src="264_a.gif"><P><h4><a name="07ea_14d3">Figure 14.1 A red-black tree with black nodes darkened and red nodes shaded. Every node in a red-black tree is either red or black, every leaf (<FONT FACE="Courier New" SIZE=2>NIL<FONT FACE="Times New Roman" SIZE=2>) is black, the children of a red node are both black, and every simple path from a node to a descendant leaf contains the same number of black nodes. Each non-<FONT FACE="Courier New" SIZE=2>NIL<FONT FACE="Times New Roman" SIZE=2> node is marked with its black-height; <FONT FACE="Courier New" SIZE=2>NIL'S<FONT FACE="Times New Roman" SIZE=2> have black-height 0.<a name="07ea_14d3"></FONT></FONT></FONT></FONT></FONT></FONT></sub></sup></h4><P>The following lemma shows why red-black trees make good search trees.<P><a name="07ea_14d4">Lemma 14.1<a name="07ea_14d4"><P>A red-black tree with <I>n</I> internal nodes has height at most 21g(<I>n</I> + 1).<P><I><B>Proof     </I></B>We first show that the subtree rooted at any node <I>x</I> contains at least 2<SUP>bh(<I>x</I>)</SUP> -1 internal nodes. We prove this claim by induction on the height of <I>x</I>. If the height of <I>x</I> is 0, then <I>x</I> must be a leaf (<FONT FACE="Courier New" SIZE=2>NIL</FONT>), and the subtree rooted at <I>x</I> indeed contains at least 2<SUP>bh(<I>x</I>)</SUP>-1 = 2<SUP>0 </SUP>- 1 = 0 internal nodes. For the inductive step, consider a node <I>x</I> that has positive height and is an internal node with two children. Each child has a black-height of either bh(<I>x</I>) or bh(<I>x</I>) - 1, depending on whether its color is red or black, respectively. Since the height of a child of <I>x</I> is less than the height of <I>x</I> itself, we can apply the inductive hypothesis to conclude that each child has at least 2<SUP>bh(<I>x</I>) -1</SUP> -1 internal nodes. Thus, the subtree rooted at <I>x</I> contains at least (2<SUP>bh(<I>x</I>)-1</SUP> -1) + (2<SUP>bh(<I>x</I>)-1</SUP> -1) + 1 = 2<SUP>bh(<I>x</I>)</SUP>- 1 internal nodes, which proves the claim.<P>To complete the proof of the lemma, let <I>h</I> be the height of the tree. According to property 3, at least half the nodes on any simple path from the root to a leaf, not including the root, must be black. Consequently, the black-height of the root must be at least <I>h</I>/2; thus,<P><pre><I>n</I> <IMG SRC="../IMAGES/gteq.gif"> 2<I><SUP>h/</I>2</SUP> - 1.</sub></sup></pre><P>Moving the 1 to the left-hand side and taking logarithms on both sides yields lg (<I>n</I> + 1) <IMG SRC="../IMAGES/gteq.gif"> <I>h</I>/2, or <I>h</I> <IMG SRC="../IMAGES/lteq12.gif"> 21g (<I>n</I> + 1).  <P><a name="07ea_14c8"><a name="07ea_14c9"><a name="07ea_14ca"><a name="07ea_14cb"><a name="07ea_14cc"><a name="07ea_14cd"><a name="07ea_14ce"><a name="07ea_14cf"><a name="07ea_14d0"><a name="07ea_14d1">An immediate consequence of this lemma is that the dynamic-set operations <FONT FACE="Courier New" SIZE=2>SEARCH</FONT>, <FONT FACE="Courier New" SIZE=2>MINIMUM</FONT>, <FONT FACE="Courier New" SIZE=2>MAXIMUM</FONT>, <FONT FACE="Courier New" SIZE=2>SUCCESSOR</FONT>, and <FONT FACE="Courier New" SIZE=2>PREDECESSOR</FONT> can be implemented in <I>O</I>(lg <I>n</I>) time on red-black trees, since they can be made to run in <I>O</I>(<I>h</I>) time on a search tree of height <I>h</I> (as shown in Chapter 13) and any red-black tree on <I>n</I> nodes is a search tree with height <I>O</I>(lg <I>n</I>). Although the algorithms <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> and <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>DELETE</FONT> from Chapter 13 run in <I>O</I>(lg <I>n</I>) time when given a red-black tree as input, they do not directly support the dynamic-set operations <FONT FACE="Courier New" SIZE=2>INSERT</FONT> and <FONT FACE="Courier New" SIZE=2>DELETE</FONT>, since they do not guarantee that the modified binary search tree will be a red-black tree. We shall see in Sections 14.3 and 14.4, however, that these two operations can indeed be supported in <I>O</I>(lg <I>n</I>) time.<P><h2><a name="07eb_0001">Exercises<a name="07eb_0001"></h2><P><a name="07eb_0002">14.1-1<a name="07eb_0002"><P>Draw the complete binary search tree of height 3 on the keys {1, 2, . . . , 15}. Add the <FONT FACE="Courier New" SIZE=2>NIL</FONT> leaves and color the nodes in three different ways such that the black-heights of the resulting red-black trees are 2, 3, and 4.<P><a name="07eb_0003">14.1-2<a name="07eb_0003"><P>Suppose that the root of a red-black tree is red. If we make it black, does the tree remain a red-black tree?<P><a name="07eb_0004">14.1-3<a name="07eb_0004"><P>Show that the longest simple path from a node <I>x</I> in a red-black tree to a descendant leaf has length at most twice that of the shortest simple path from node <I>x</I> to a descendant leaf.<P><a name="07eb_0005">14.1-4<a name="07eb_0005"><P>What is the largest possible number of internal nodes in a red-black tree with black-height <I>k</I>? What is the smallest possible number?<P><a name="07eb_0006">14.1-5<a name="07eb_0006"><P>Describe a red-black tree on <I>n</I> keys that realizes the largest possible ratio of red internal nodes to black internal nodes. What is this ratio? What tree has the smallest possible ratio, and what is the ratio?<P><P><P><h1><a name="07ec_14d6">14.2 Rotations<a name="07ec_14d6"></h1><P><a name="07ec_14d2"><a name="07ec_14d3">The search-tree operations <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> and <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>, when run on a red-black tree with <I>n</I> keys, take <I>O</I>(lg <I>n</I>) time. Because they modify the tree, the result may violate the red-black properties enumerated in Section 14.1. To restore these properties, we must change the colors of some of the nodes in the tree and also change the pointer structure.<P><img src="266_a.gif"><P><h4><a name="07ec_14d7">Figure 14.2 The rotation operations on a binary search tree. The operation <FONT FACE="Courier New" SIZE=2>RIGHT<FONT FACE="Times New Roman" SIZE=2>-<FONT FACE="Courier New" SIZE=2>ROTATE</FONT></FONT></FONT>(T,x) transforms the configuration of the two nodes on the left into the configuration on the right by changing a constant number of pointers. The configuration on the right can be transformed into the configuration on the left by the inverse operation <FONT FACE="Courier New" SIZE=2>LEFT<FONT FACE="Times New Roman" SIZE=2>-<FONT FACE="Courier New" SIZE=2>ROTATE</FONT></FONT></FONT>(T,y). The two nodes might occur anywhere in a binary search tree. The letters <IMG SRC="../IMAGES/alpha12.gif">, <IMG SRC="../IMAGES/beta14.gif">, and <IMG SRC="../IMAGES/gamma14.gif"> represent arbitrary subtrees. A rotation operation preserves the inorder ordering of keys: the keys in <IMG SRC="../IMAGES/alpha12.gif"> precede key[x], which precedes the keys in <IMG SRC="../IMAGES/beta14.gif">, which precede key[y], which precedes the keys in <IMG SRC="../IMAGES/gamma14.gif">.<a name="07ec_14d7"></sub></sup></h4><P>We change the pointer structure through <I><B>rotation</I></B>, which is a local operation in a search tree that preserves the inorder key ordering. Figure 14.2 shows the two kinds of rotations: left rotations and right rotations. When we do a left rotation on a node <I>x</I>, we assume that its right child <I>y</I> is non-<FONT FACE="Courier New" SIZE=2>NIL</FONT>. The left rotation &quot;pivots&quot; around the link from <I>x</I> to <I>y</I>. It makes <I>y</I> the new root of the subtree, with <I>x</I> as <I>y</I>'s left child and <I>y</I>'s left child as <I>x</I>'s right child.<P><a name="07ec_14d4">The pseudocode for <FONT FACE="Courier New" SIZE=2>LEFT</FONT>-<FONT FACE="Courier New" SIZE=2>ROTATE</FONT> assumes that <I>right</I>[<I>x</I>] <IMG SRC="../IMAGES/noteq.gif"> <FONT FACE="Courier New" SIZE=2>NIL</FONT>.<P><img src="266_b.gif"><P><a name="07ec_14d5">Figure 14.3 shows how <FONT FACE="Courier New" SIZE=2>LEFT</FONT>-<FONT FACE="Courier New" SIZE=2>ROTATE</FONT> operates. The code for <FONT FACE="Courier New" SIZE=2>RIGHT</FONT>-<FONT FACE="Courier New" SIZE=2>ROTATE</FONT> is similar. Both <FONT FACE="Courier New" SIZE=2>LEFT</FONT>-<FONT FACE="Courier New" SIZE=2>ROTATE</FONT> and <FONT FACE="Courier New" SIZE=2>RIGHT</FONT>-<FONT FACE="Courier New" SIZE=2>ROTATE</FONT> run in <I>O</I>(l) time. Only pointers are changed by a rotation; all other fields in a node remain the same.<P><img src="267_a.gif"><P><h4><a name="07ec_14d8">Figure 14.3 An example of how the procedure <FONT FACE="Courier New" SIZE=2>LEFT<FONT FACE="Times New Roman" SIZE=2>-<FONT FACE="Courier New" SIZE=2>ROTATE</FONT></FONT></FONT>(T,x) modifies a binary search tree. The <FONT FACE="Courier New" SIZE=2>NIL</FONT> leaves are omitted. Inorder tree walks of the input tree and the modified tree produce the same listing of key values.<a name="07ec_14d8"></sub></sup></h4><P><h2><a name="07ed_14d7">Exercises<a name="07ed_14d7"></h2><P><a name="07ed_14d8">14.2-1<a name="07ed_14d8"><P>Draw the red-black tree that results after <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> is called on the tree in Figure 14.1 with key 36. If the inserted node is colored red, is the resulting tree a red-black tree? What if it is colored black?<P><a name="07ed_14d9">14.2-2<a name="07ed_14d9"><P>Write pseudocode for <FONT FACE="Courier New" SIZE=2>RIGHT</FONT>-<FONT FACE="Courier New" SIZE=2>ROTATE</FONT>.<P><a name="07ed_14da">14.2-3<a name="07ed_14da"><P>Argue that rotation preserves the inorder key ordering of a binary tree.<P><a name="07ed_14db">14.2-4<a name="07ed_14db"><P><a name="07ed_14d6">Let <I>a, b</I>, and <I>c</I> be arbitrary nodes in subtrees <IMG SRC="../IMAGES/alpha12.gif"><I>, <IMG SRC="../IMAGES/beta14.gif"></I>, and <IMG SRC="../IMAGES/gamma14.gif"><I></I>, respectively, in the left tree of Figure 14.2. How do the depths of <I>a, b</I>, and <I>c</I> change when a left rotation is performed on node <I>x</I> in the figure?<P><a name="07ed_14dc">14.2-5<a name="07ed_14dc"><P>Show that any arbitrary <I>n</I>-node tree can be transformed into any other arbitrary <I>n</I>-node tree using <I>O</I>(<I>n</I>) rotations. (<I>Hint</I>: First show that at most <I>n</I> -1 right rotations suffice to transform any tree into a right-going chain.)<P><P><P><h1><a name="07ee_14db">14.3 Insertion<a name="07ee_14db"></h1><P><a name="07ee_14d7"><a name="07ee_14d8"><a name="07ee_14d9"><a name="07ee_14da">Insertion of a node into an <I>n</I>-node red-black tree can be accomplished in <I>O</I>(lg <I>n</I>) time. We use the <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> procedure (Section 13.3) to insert node <I>x</I> into the tree <I>T</I> as if it were an ordinary binary search tree, and then we color <I>x</I> red. To guarantee that the red-black properties are preserved, we then fix up the modified tree by recoloring nodes and performing rotations. Most of the code for RB-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> handles the various cases that can arise as we fix up the modified tree.<P><img src="268_a.gif"><P>The code for RB-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> is less imposing than it looks. We shall break our examination of the code into three major steps. First, we shall determine what violations of the red-black properties are introduced in lines 1-2 when the node <I>x</I> is inserted and colored red. Second, we shall examine the overall goal of the <B>while</B> loop in lines 3-17. Finally, we shall explore each of the three cases into which the <B>while</B> loop is broken and see how they accomplish the goal. Figure 14.4 shows how RB-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> operates on a sample red-black tree.<P>Which of the red-black properties can be violated after lines 1-2? Property 1 certainly continues to hold, as does property 2, since the newly inserted red node has <FONT FACE="Courier New" SIZE=2>NIL'S</FONT> for children. Property 4, which says that the number of blacks is the same on every path from a given node, is satisfied as well, because node <I>x</I> replaces a (black) <FONT FACE="Courier New" SIZE=2>NIL</FONT>, and node <I>x</I> is red with <FONT FACE="Courier New" SIZE=2>NIL</FONT> children. Thus, the only property that might be violated is property 3 which says that a red node cannot have a red child. Specifically, property 3 is violated if <I>x</I><FONT FACE="CG Times (W1)" SIZE=2>'</FONT>s parent is red, since <I>x</I> is itself colored red in line 2. Figure 14.4(a) shows such a violation after the node <I>x</I> has been inserted.<P><img src="269_a.gif"><P><h4><a name="07ee_14dc">Figure 14.4 The operation of RB-<FONT FACE="Courier New" SIZE=2>INSERT</FONT>. (a) A node x after insertion. Since x and its parent p[x] are both red, a violation of property 3 occurs. Since x's uncle y is red, case 1 in the code can be applied. Nodes are recolored and the pointer x is moved up the tree, resulting in the tree shown in (b). Once again, x and its parent are both red, but x's uncle y is black. Since x is the right child of p[x], case 2 can be applied. A left rotation is performed, and the tree that results is shown in (c). Now x is the left child of its parent, and case 3 can be applied. A right rotation yields the tree in (d), which is a legal red-black tree.<a name="07ee_14dc"></sub></sup></h4><P>The goal of the <B>while</B> loop in lines 3-17 is to move the one violation of property 3 up the tree while maintaining property 4 as an invariant. At the beginning of each iteration of the loop, <I>x</I> points to a red node with a red parent--the only violation in the tree. There are two possible outcomes of each iteration of the loop: the pointer <I>x</I> moves up the tree, or some rotations are performed and the loop terminates.<P>There are actually six cases to consider in the <B>while</B> loop, but three of them are symmetric to the other three, depending on whether <I>x</I><FONT FACE="CG Times (W1)" SIZE=2>'</FONT>s parent <I>p</I>[<I>x</I>] is a left child or a right child of <I>x</I><FONT FACE="CG Times (W1)" SIZE=2>'</FONT>s grandparent <I>p</I>[<I>p</I>[<I>x</I>]]<I>,</I> which is determined in line 4. We have given the code only for the situation in which <I>p</I>[<I>x</I>] is a left child. We have made the important assumption that the root of the tree is black--a property we guarantee in line 18 each time we terminate--so that <I>p</I>[<I>x</I>] is not the root and <I>p</I>[<I>p</I>[<I>x</I>]] exists.<P>Case 1 is distinguished from cases 2 and 3 by the color of <I>x'</I>s parent's sibling, or &quot;uncle.&quot; Line 5 makes <I>y</I> point to <I>x</I>'s uncle <I>right</I> [<I>p</I>[<I>p</I>[<I>x</I>]]], and a test is made in line 6. If <I>y</I> is red, then case 1 is executed. Otherwise, control passes to cases 2 and 3. In all three cases, <I>x</I>'s grandparent <I>p</I>[<I>p</I>[<I>x</I>]] is black, since its parent <I>p</I>[<I>x</I>] is red, and property 3 is violated only between <I>x</I> and <I>p</I>[<I>x</I>]<I>.</I><P>The situation for case 1 (lines 7-10) is shown in Figure 14.5. Case 1 is executed when both <I>p</I>[<I>x</I>] and <I>y</I> are red. Since <I>p</I>[<I>p</I>[<I>x</I>]] is black, we can color both <I>p</I>[<I>x</I>] and <I>y</I> black, thereby fixing the problem of <I>x</I> and <I>p</I>[<I>x</I>] both being red, and color <I>p</I>[<I>p</I>[<I>x</I>]] red, thereby maintaining property 4. The only problem that might arise is that <I>p</I>[<I>p</I>[<I>x</I>]] might have a red parent; hence, we must repeat the <B>while</B> loop with <I>p</I>[<I>p</I>[<I>x</I>]] as the new node <I>x</I>.<P>In cases 2 and 3, the color of <I>x</I>'s uncle <I>y</I> is black. The two cases are distinguished by whether <I>x</I> is a right or left child of <I>p</I>[<I>x</I>]<I>.</I> Lines 12-13 constitute case 2, which is shown in Figure 14.6 together with case 3. In case 2, node <I>x</I> is a right child of its parent. We immediately use a left rotation to transform the situation into case 3 (lines 14-16), in which node <I>x</I> is a left child. Because both <I>x</I> and <I>p</I>[<I>x</I>] are red, the rotation affects neither the black-height of nodes nor property 4. Whether we enter case 3 directly or through case 2, <I>x'</I>s uncle <I>y</I> is black, since otherwise we would have executed case 1. We execute some color changes and a right rotation, which preserve property 4, and then, since we no longer have two red nodes in a row, we are done. The body of the <B>while</B> loop is not executed another time, since <I>p</I>[<I>x</I>] is now black.<P>What is the running time of RB-<FONT FACE="Courier New" SIZE=2>INSERT</FONT>? Since the height of a red-black tree on <I>n</I> nodes is <I>O(</I>lg <I>n),</I> the call to <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> takes <I>O(</I>lg <I>n</I>)<I> </I>time. The <B>while</B> loop only repeats if case 1 is executed, and then the pointer <I>x</I> moves up the tree. The total number of times the <B>while</B> loop can be executed is therefore <I>O(</I>lg <I>n)</I>. Thus, RB-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> takes a total of <I>O</I>(lg <I>n</I>) time. Interestingly, it never performs more than two rotations, since the <B>while</B> loop terminates if case 2 or case 3 is executed.<P><img src="271_a.gif"><P><h4><a name="07ee_14dd">Figure 14.5 Case 1 of the procedure RB-<FONT FACE="Courier New" SIZE=2>INSERT</FONT>. Property 3 is violated, since x and its parent p[x] are both red. The same action is taken whether (a) x is a right child or (b) x is a left child. Each of the subtrees <FONT FACE="Courier New" SIZE=2><IMG SRC="../IMAGES/alpha12.gif">, <IMG SRC="../IMAGES/beta14.gif">, <IMG SRC="../IMAGES/gamma14.gif">, <IMG SRC="../IMAGES/delta12.gif"><FONT FACE="Times New Roman" SIZE=2> </FONT></FONT>and <FONT FACE="Courier New" SIZE=2><IMG SRC="../IMAGES/epsilon.gif"><FONT FACE="Times New Roman" SIZE=2></FONT></FONT> has a black root, and each has the same black-height. The code for case 1 changes the colors of some nodes, preserving property 4: all downward paths from a node to a leaf have the same number of blacks. The while loop continues with node x's grandparent p[p[x]] as the new x. Any violation of property 3 can now occur only between the new x, which is red, and its parent, if it is red as well.<a name="07ee_14dd"></sub></sup></h4><P><img src="271_b.gif"><P><h4><a name="07ee_14de">Figure 14.6 Cases 2 and 3 of the procedure RB-<FONT FACE="Courier New" SIZE=2>INSERT</FONT>. As in case 1, property 3 is violated in either case 2 or case 3 because x and its parent p[x] are both red. Each of the subtrees <FONT FACE="Courier New" SIZE=2><IMG SRC="../IMAGES/alpha12.gif">, <IMG SRC="../IMAGES/beta14.gif">, <IMG SRC="../IMAGES/gamma14.gif">, <FONT FACE="Times New Roman" SIZE=2></FONT></FONT>and <FONT FACE="Courier New" SIZE=2><IMG SRC="../IMAGES/delta12.gif"> </FONT>has a black root, and each has the same black-height. Case 2 is transformed into case 3 by a left rotation, which preserves property 4: all downward paths from a node to a leaf have the same number of blacks. Case 3 causes some color changes and a right rotation, which also preserve property 4. The while loop then terminates, because property 3 is satisfied: there are no longer two red nodes in a row.<a name="07ee_14de"></sub></sup></h4><P><h2><a name="07ef_0001">Exercises<a name="07ef_0001"></h2><P><a name="07ef_0002">14.3-1<a name="07ef_0002"><P>In line 2 of RB-<FONT FACE="Courier New" SIZE=2>INSERT</FONT>, we set the color of the newly inserted node <I>x</I> to red. Notice that if we had chosen to set <I>x</I>'s color to black, then property 3 of a red-black tree would not be violated. Why didn<FONT FACE="CG Times (W1)" SIZE=2>'</FONT>t we choose to set <I>x</I><FONT FACE="CG Times (W1)" SIZE=2>'</FONT>s color to black?<P><a name="07ef_0003">14.3-2<a name="07ef_0003"><P>In line 18 of RB-<FONT FACE="Courier New" SIZE=2>INSERT</FONT>, we set the root's color to black. What is the advantage of doing so?<P><a name="07ef_0004">14.3-3<a name="07ef_0004"><P>Show the red-black trees that result after successively inserting the keys 41, 38, 31, 12, 19, 8 into an initially empty red-black tree.<P><a name="07ef_0005">14.3-4<a name="07ef_0005"><P>Suppose that the black-height of each of the subtrees<I> </I><IMG SRC="../IMAGES/alpha12.gif">, <I><IMG SRC="../IMAGES/beta14.gif">, </I><IMG SRC="../IMAGES/gamma14.gif">, <I><IMG SRC="../IMAGES/delta12.gif">, </I><IMG SRC="../IMAGES/epsilon.gif"><I></I> in Figures 14.5 and 14.6 is <I>k</I>. Label each node in each figure with its black-height to verify that property 4 is preserved by the indicated transformation.<P><a name="07ef_0006">14.3-5<a name="07ef_0006"><P>Consider a red-black tree formed by inserting <I>n</I> nodes with <FONT FACE="Courier New" SIZE=2>RB-INSERT</FONT>. Argue that if <I>n</I> &gt; 1, the tree has at least one red node.<P><a name="07ef_0007">14.3-6<a name="07ef_0007"><P>Suggest how to implement <FONT FACE="Courier New" SIZE=2>RB-INSERT</FONT> efficiently if the representation for red-black trees includes no storage for parent pointers.<P><P><P><h1><a name="07f0_14e1">14.4 Deletion<a name="07f0_14e1"></h1><P><a name="07f0_14db"><a name="07f0_14dc">Like the other basic operations on an <I>n</I>-node red-black tree, deletion of a node takes time <I>O</I>(lg <I>n</I>). Deleting a node from a red-black tree is only slightly more complicated than inserting a node.<P><a name="07f0_14dd">In order to simplify boundary conditions in the code, we use a sentinel to represent <FONT FACE="Courier New" SIZE=2>NIL</FONT> (see page 206). For a red-black tree <I>T,</I> the sentinel <I>nil</I>[<I>T</I>]<I> </I>is an object with the same fields as an ordinary node in the tree. Its <I>color</I> field is <FONT FACE="Courier New" SIZE=2>BLACK</FONT>, and its other fields--<I>p, left, right,</I> and <I>key</I>--can be set to arbitrary values. In the red-black tree, all pointers to <FONT FACE="Courier New" SIZE=2>NIL</FONT> are replaced by pointers to the sentinel <I>nil</I>[<I>T</I>]<I>.</I><P>We use sentinels so that we can treat a <FONT FACE="Courier New" SIZE=2>NIL</FONT> child of a node <I>x</I> as an ordinary node whose parent is <I>x.</I> We could add a distinct sentinel node for each <FONT FACE="Courier New" SIZE=2>NIL</FONT> in the tree, so that the parent of each <FONT FACE="Courier New" SIZE=2>NIL</FONT> is well defined, but that would waste space. Instead, we use the one sentinel <I>nil</I>[<I>T</I>] to represent all the <FONT FACE="Courier New" SIZE=2>NIL'S</FONT>. When we wish to manipulate a child of a node <I>x, </I>however, we must be careful to set <I>p</I>[<I>nil</I>[<I>T</I>]] to <I>x</I> first.<P><a name="07f0_14de"><a name="07f0_14df"><a name="07f0_14e0">The procedure RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT> is a minor modification of the <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>DELETE</FONT> procedure (Section 13.3). After splicing out a node, it calls an auxiliary procedure RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>-<FONT FACE="Courier New" SIZE=2>FIXUP</FONT> that changes colors and performs rotations to restore the red-black properties.<P><pre>RB-DELETE (<I>T, z</I>)</sub></sup></pre><P><pre>1 <B>if</B> left[z] = nil[T] or right[z] = nil[T]</sub></sup></pre><P><pre>2      <B>then</B> y <IMG SRC="../IMAGES/arrlt12.gif"> z</sub></sup></pre><P><pre>3      <B>else</B> y <IMG SRC="../IMAGES/arrlt12.gif"> TREE-SUCCESSOR(z)</sub></sup></pre><P><pre>4 <B>if</B> left[y] <IMG SRC="../IMAGES/noteq.gif"> nil[T]     </sub></sup></pre><P><pre>5     <B>then</B> x <IMG SRC="../IMAGES/arrlt12.gif"> left[y]</sub></sup></pre><P><pre>6     <B>else</B> x <IMG SRC="../IMAGES/arrlt12.gif"> right[y]</sub></sup></pre><P><pre>7 p[x] <IMG SRC="../IMAGES/arrlt12.gif"> p[y]</sub></sup></pre><P><pre>8 <B>if</B> p[y] = nil[T]</sub></sup></pre><P><pre>9    <B>then</B> root[T] <IMG SRC="../IMAGES/arrlt12.gif"> x</sub></sup></pre><P><pre>10    <B>else if</B> <I>y = left</I>[<I>p</I>[<I>y</I>]]</sub></sup></pre><P><pre>11            <B>then</B> <I>left</I>[<I>p</I>[<I>y</I>]]<I> </I><IMG SRC="../IMAGES/arrlt12.gif"> x</sub></sup></pre><P><pre>12            <B>else</B> <I>right</I>[<I>p</I>[<I>y</I>]] <IMG SRC="../IMAGES/arrlt12.gif"><I> x</I></sub></sup></pre><P><pre>13 <B>if</B> <I>y </I><IMG SRC="../IMAGES/noteq.gif"> z</sub></sup></pre><P><pre>14     <B>then</B> <I>key</I>[<I>z</I>] <IMG SRC="../IMAGES/arrlt12.gif"><I> key</I>[<I>y</I>]</sub></sup></pre><P><pre>15          <img src="273_a.gif"> If <I>y</I> has other fields, copy them, too.</sub></sup></pre><P><pre>16 <B>if</B> <I>color</I>[<I>y</I>] = BLACK</sub></sup></pre><P><pre>17     <B>then</B> RB-DELETE-FIXUP (<I>T,x</I>)</sub></sup></pre><P><pre>18 <B>return</B> <I>y</I></sub></sup></pre><P>There are three differences between the procedures <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>DELETE</FONT> and RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>. First, all references to <FONT FACE="Courier New" SIZE=2>NIL</FONT> in <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>DELETE</FONT> have been replaced by references to the sentinel <I>nil</I>[<I>T</I>] in RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>. Second, the test for whether <I>x</I> is <FONT FACE="Courier New" SIZE=2>NIL</FONT> in line 7 of <FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>DELETE</FONT> has been removed, and the assignment <I>p</I>[<I>x</I>]<I> </I><IMG SRC="../IMAGES/arrlt12.gif"><I> p</I>[<I>y</I>] is performed unconditionally in line 7 of RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>. Thus, if <I>x</I> is the sentinel <I>nil</I>[<I>T</I>], its parent pointer points to the parent of the spliced-out node <I>y</I>. Third, a call to RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>-<FONT FACE="Courier New" SIZE=2>FIXUP</FONT> is made in lines 16-17 if <I>y</I> is black. If <I>y</I> is red, the red-black properties still hold when <I>y</I> is spliced out, since no black-heights in the tree have changed and no red nodes have been made adjacent. The node <I>x</I> passed to RB-<FONT FACE="Courier New" SIZE=2>DELETE-FIXUP</FONT> is the node that was <I>y</I>'s sole child before <I>y</I> was spliced out if <I>y</I> had a non-<FONT FACE="Courier New" SIZE=2>NIL</FONT> child, or the sentinel <I>nil</I>[<I>T</I>] if <I>y</I> had no children. In the latter case, the unconditional assignment in line 7 guarantees that <I>x</I>'s parent is now the node that was previously <I>y</I>'s parent, whether <I>x</I> is a key-bearing internal node or the sentinel <I>nil</I>[<I>T</I>].<P>We can now examine how the procedure RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>-<FONT FACE="Courier New" SIZE=2>FIXUP</FONT> restores the red-black properties to the search tree.<P><img src="274_a.gif"><P>If the spliced-out node <I>y</I> in RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT> is black, its removal causes any path that previously contained node <I>y</I> to have one fewer black node. Thus, property 4 is now violated by any ancestor of <I>y</I> in the tree. We can correct this problem by thinking of node <I>x</I> as having an &quot;extra&quot; black. That is, if we add 1 to the count of black nodes on any path that contains <I>x</I>, then under this interpretation, property 4 holds. When we splice out the black node <I>y</I>, we <FONT FACE="CG Times (W1)" SIZE=2>&quot;</FONT>push&quot; its blackness onto its child. The only problem is that now node <I>x</I> may be &quot;doubly black,&quot; thereby violating property 1.<P>The procedure RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>-<FONT FACE="Courier New" SIZE=2>FIXUP</FONT> attempts to restore property 1. The goal of the <B>while</B> loop in lines 1-22 is to move the extra black up the tree until (1) <I>x</I> points to a red node, in which case we color the node black in line 23, (2) <I>x</I> points to the root, in which case the extra black can be simply <FONT FACE="CG Times (W1)" SIZE=2>&quot;</FONT>removed,&quot; or (3) suitable rotations and recolorings can be performed.<P>Within the <B>while</B> loop, <I>x</I> always points to a nonroot black node that has the extra black. We determine in line 2 whether <I>x</I> is a left child or a right child of its parent <I>p</I>[<I>x</I>]. (We have given the code for the situation in which <I>x</I> is a left child; the situation in which <I>x</I> is a right child--line 22--is symmetric.) We maintain a pointer <I>w</I> to the sibling of <I>x</I>. Since node <I>x</I> is doubly black, node <I>w</I> cannot be <I>nil</I>[<I>T</I>]; otherwise, the number of blacks on the path from <I>p</I>[<I>x</I>] to the <FONT FACE="Courier New" SIZE=2>NIL</FONT> leaf <I>w</I> would be smaller than the number on the path from <I>p</I>[<I>x</I>] to <I>x</I>.<P>The four cases in the code are illustrated in Figure 14.7. Before examining each case in detail, let's look more generally at how we can verify that the transformation in each of the cases preserves property 4. The key idea is that in each case the number of black nodes from (and including) the root of the subtree shown to each of the subtrees <IMG SRC="../IMAGES/alpha12.gif">, <I><IMG SRC="../IMAGES/beta14.gif">,</I> . . ., <IMG SRC="../IMAGES/zeta12.gif"><I></I> is preserved by the transformation. For example, in Figure 14.7(a), which illustrates case 1, the number of black nodes from the root to either subtree <IMG SRC="../IMAGES/alpha12.gif"><I> or <IMG SRC="../IMAGES/beta14.gif"></I> is 3, both before and after the transformation. (Remember, the pointer <I>x</I> adds an extra black.) Similarly, the number of black nodes from the root to any of <IMG SRC="../IMAGES/gamma14.gif">, <I><IMG SRC="../IMAGES/delta12.gif">, </I><IMG SRC="../IMAGES/epsilon.gif">,<I> and <IMG SRC="../IMAGES/zeta12.gif"></I> is 2, both before and after the transformation. In Figure 14.7(b), the counting must involve the color <I>c</I>, which can be either red or black. If we define count(<FONT FACE="Courier New" SIZE=2>RED</FONT>) = 0 and count(<FONT FACE="Courier New" SIZE=2>BLACK</FONT>) = 1, then the number of black nodes from the root to <IMG SRC="../IMAGES/alpha12.gif"><I></I> is 2 + count(<I>c</I>), both before and after the transformation. The other cases can be verified similarly (Exercise 14.4-5).<P>Case 1 (lines 5-8 of RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>-<FONT FACE="Courier New" SIZE=2>FIXUP</FONT> and Figure 14.7(a)) occurs when node <I>w</I>, the sibling of node <I>x</I>, is red. Since <I>w</I> must have black children, we can switch the colors of <I>w</I> and <I>p</I>[<I>x</I>] and then perform a left-rotation on <I>p</I>[<I>x</I>] without violating any of the red-black properties. The new sibling of <I>x</I>, one of <I>w</I>'s children, is now black, and thus we have converted case 1 into case 2, 3, or 4.<P>Cases 2, 3, and 4 occur when node <I>w</I> is black; they are distinguished by the colors of <I>w</I>'s children. In case 2 (lines 10-11 of RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>-<FONT FACE="Courier New" SIZE=2>FIXUP</FONT> and Figure 14.7(b)), both of <I>w</I>'s children are black. Since <I>w</I> is also black, we take one black off both <I>x</I> and <I>w</I>, leaving <I>x</I> with only one black and leaving <I>w</I> red, and add an extra black to <I>p</I>[<I>x</I>]. We then repeat the <B>while</B> loop with <I>p</I>[<I>x</I>] as the new node <I>x</I>. Observe that if we enter case 2 through case 1, the color <I>c</I> of the new node <I>x</I> is red, since the original <I>p</I>[<I>x</I>] was red, and thus the loop terminates when it tests the loop condition.<P>Case 3 (lines 13-16 and Figure 14.7(c)) occurs when <I>w</I> is black, its left child is red, and its right child is black. We can switch the colors of <I>w</I> and its left child <I>left</I>[<I>w</I>] and then perform a right rotation on <I>w</I> without violating any of the red-black properties. The new sibling <I>w</I> of <I>x</I> is now a black node with a red right child, and thus we have transformed case 3 into case 4. <P>Case 4 (lines 17-21 and Figure 14.7(d)) occurs when node <I>x</I>'s sibling <I>w</I> is black and <I>w</I>'s right child is red. By making some color changes and performing a left rotation on <I>p</I>[<I>x</I>], we can remove the extra black on <I>x</I> without violating any of the red-black properties. Setting <I>x</I> to be the root causes the <B>while</B> loop to terminate when it tests the loop condition.<P><img src="276_a.gif"><P><h4><a name="07f0_14e2">Figure 14.7 The cases in the while loop of the procedure RB-<FONT FACE="Courier New" SIZE=3><FONT FACE="Courier New" SIZE=1>DELETE</FONT></FONT>. Darkened nodes are black, heavily shaded nodes are red, and lightly shaded nodes, which may be either red or black, are represented by c and c'. The letters <IMG SRC="../IMAGES/alpha12.gif">, <IMG SRC="../IMAGES/beta14.gif">, . . ., <IMG SRC="../IMAGES/zeta12.gif"> represent arbitrary subtrees. In each case, the configuration on the left is transformed into the configuration on the right by changing some colors and/or performing a rotation. A node pointed to by x has an extra black. The only case that causes the loop to repeat is case 2. (a) Case I is transformed to case 2, 3, or 4 by exchanging the colors of nodes B and D and performing a left rotation. (b) In case 2, the extra black represented by the pointer x is moved up the tree by coloring node D red and setting x to point to node B. If we enter case 2 through case 1, the while loop terminates, since the color c is red. (c) Case 3 is transformed to case 4 by exchanging the colors of nodes C and D and performing a right rotation. (d) In case 4, the extra black represented by x can be removed by changing some colors and performing a left rotation (without violating the red-black properties), and the loop terminates.<a name="07f0_14e2"></sub></sup></h4><P>What is the running time of RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>? Since the height of a red-black tree of <I>n</I> nodes is <I>O</I>(lg <I>n</I>), the total cost of the procedure without the call to RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>-<FONT FACE="Courier New" SIZE=2>FIXUP</FONT> takes <I>O</I>(lg <I>n</I>) time. Within RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>-<FONT FACE="Courier New" SIZE=2>FIXUP</FONT>, cases 1, 3, and 4 each terminate after performing a constant number of color changes and at most three rotations. Case 2 is the only case in which the <B>while</B> loop can be repeated, and then the pointer <I>x</I> moves up the tree at most <I>O</I>(lg <I>n</I>) times and no rotations are performed. Thus, the procedure RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>-<FONT FACE="Courier New" SIZE=2>FIXUP</FONT> takes <I>O</I>(lg <I>n</I>) time and performs at most three rotations, and the overall time for RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT> is therefore also <I>O</I>(lg <I>n</I>).<P><h2><a name="07f1_14e3">Exercises<a name="07f1_14e3"></h2><P><a name="07f1_14e4">14.4-1<a name="07f1_14e4"><P>Argue that the root of the red-black tree is always black after RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT> executes. <P><a name="07f1_14e5">14.4-2<a name="07f1_14e5"><P>In Exercise 14.3-3, you found the red-black tree that results from successively inserting the keys 41, 38, 31, 12,19, 8 into an initially empty tree. Now show the red-black trees that result from the successive deletion of the keys in the order 8, 12, 19, 31, 38, 41.<P><a name="07f1_14e6">14.4-3<a name="07f1_14e6"><P><a name="07f1_14e1">In which lines of the code for RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>-<FONT FACE="Courier New" SIZE=2>FIXUP</FONT> might we examine or modify the sentinel <I>nil</I>[<I>T</I>]?<P><a name="07f1_14e7">14.4-4<a name="07f1_14e7"><P><a name="07f1_14e2">Simplify the code for <FONT FACE="Courier New" SIZE=2>LEFT</FONT>-<FONT FACE="Courier New" SIZE=2>ROTATE</FONT> by using a sentinel for <FONT FACE="Courier New" SIZE=2>NIL</FONT> and another sentinel to hold the pointer to the root.<P><a name="07f1_14e8">14.4-5<a name="07f1_14e8"><P>In each of the cases of Figure 14.7, give the count of black nodes from the root of the subtree shown to each of the subtrees <IMG SRC="../IMAGES/alpha12.gif">,<I><IMG SRC="../IMAGES/beta14.gif">,</I> . . ., <IMG SRC="../IMAGES/zeta12.gif"><I>,</I> and verify that each count remains the same after the transformation. When a node has a color <I>c</I> or <I>c</I>', use the notation count(<I>c</I>) or count(<I>c</I>') symbolically in your count.<P><a name="07f1_14e9">14.4-6<a name="07f1_14e9"><P>Suppose that a node <I>x</I> is inserted into a red-black tree with RB-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> and then immediately deleted with RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT>. Is the resulting red-black tree the same as the initial red-black tree? Justify your answer.<P><P><P><h1><a name="07f2_14ea">Problems<a name="07f2_14ea"></h1><P><a name="07f2_14eb">14-1     Persistent dynamic sets<a name="07f2_14eb"><P><a name="07f2_14e3"><a name="07f2_14e4"><a name="07f2_14e5">During the course of an algorithm, we sometimes find that we need to maintain past versions of a dynamic set as it is updated. Such a set is called <I><B>persistent.</I></B> One way to implement a persistent set is to copy the entire set whenever it is modified, but this approach can slow down a program and also consume much space. Sometimes, we can do much better.<P>Consider a persistent set <I>S</I> with the operations <FONT FACE="Courier New" SIZE=2>INSERT</FONT>, <FONT FACE="Courier New" SIZE=2>DELETE</FONT>, and <FONT FACE="Courier New" SIZE=2>SEARCH</FONT>, which we implement using binary search trees as shown in Figure 14.8(a). We maintain a separate root for every version of the set. In order to insert the key 5 into the set, we create a new node with key 5. This node becomes the left child of a new node with key 7, since we cannot modify the existing node with key 7. Similarly, the new node with key 7 becomes the left child of a new node with key 8 whose right child is the existing node with key 10. The new node with key 8 becomes, in turn, the right child of a new root <I>r</I>' with key 4 whose left child is the existing node with key 3. We thus copy only part of the tree and share some of the nodes with the original tree, as shown in Figure 14.8(b).<P><I><B>a.     </I></B>For a general persistent binary search tree, identify the nodes that need to be changed to insert a key <I>k</I> or delete a node <I>y</I>.<P><a name="07f2_14e6"><I><B>b.     </I></B>Write a procedure <FONT FACE="Courier New" SIZE=2>PERSISTENT</FONT>-<FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> that, given a persistent tree <I>T</I> and a key <I>k</I> to insert, returns a new persistent tree <I>T'</I> that is the result of inserting <I>k</I> into <I>T</I>. Assume that each tree node has the fields <I>key</I>, <I>left</I>, and <I>right</I> but no parent field. (See also Exercise 14.3-6.)<P><I><B>c.     </I></B>If the height of the persistent binary search tree <I>T</I> is <I>h</I>, what are the time and space requirements of your implementation of <FONT FACE="Courier New" SIZE=2>PERSISTENT</FONT>-<FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>INSERT</FONT>? (The space requirement is proportional to the number of new nodes allocated.)<P><I><B>d.</I></B>     Suppose that we had included the parent field in each node. In this case, <FONT FACE="Courier New" SIZE=2>PERSISTENT</FONT>-<FONT FACE="Courier New" SIZE=2>TREE</FONT>-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> would need to perform additional copying. Prove that P<FONT FACE="Courier New" SIZE=2>ERSISTENT-</FONT>T<FONT FACE="Courier New" SIZE=2>REE-</FONT><FONT FACE="Courier New" SIZE=2>INSERT</FONT> would then require <IMG SRC="../IMAGES/omega12.gif">(<I>n</I>) time and space, where <I>n</I> is the number of nodes in the tree.<P><I><B>e.     </I></B>Show how to use red-black trees to guarantee that the worst-case running time and space is <I>O</I>(lg <I>n</I>) per insertion or deletion.<P><a name="07f2_14ec">14-2     Join operation on red-black trees<a name="07f2_14ec"><P><a name="07f2_14e7"><a name="07f2_14e8"><a name="07f2_14e9">The <I><B>join </I></B>operation takes two dynamic sets <I>S</I><SUB>1</SUB> and <I>S</I><SUB>2</SUB> and an element <I>x</I> such that for any <I>x</I><SUB>1</SUB> <IMG SRC="../IMAGES/memof12.gif"> <I>S</I><SUB>1</SUB> and <I>x</I><SUB>2 </SUB><IMG SRC="../IMAGES/memof12.gif"> <I>S</I><SUB>2</SUB>, we have <I>key</I>[<I>x</I><SUB>1</SUB>] <IMG SRC="../IMAGES/lteq12.gif"> <I>key</I>[<I>x</I>]<I> </I><IMG SRC="../IMAGES/lteq12.gif"> <I>key</I>[<I>x</I><SUB>2</SUB>]. It returns a set <I>S</I> = <I>S</I><SUB>1</SUB> <IMG SRC="../IMAGES/wideu.gif"> {<I>x</I>} <IMG SRC="../IMAGES/wideu.gif"> <I>S</I><SUB>2</SUB>. In this problem, we investigate how to implement the join operation on red-black trees.<P><img src="279_a.gif"><P><h4><a name="07f2_14ed">Figure 14.8 (a) A binary search tree with keys 2, 3, 4, 7, 8, 10. (b) The persistent binary search tree that results from the insertion of key 5. The most recent version of the set consists of the nodes reachable from the root r', and the previous version consists of the nodes reachable from r. Heavily shaded nodes are added when key 5 is inserted.<a name="07f2_14ed"></sub></sup></h4><P><I><B>a.</I></B>     Given a red-black tree <I>T</I>, we store its black-height as the field <I>bh</I>[<I>T</I>]. Argue that this field can be maintained by RB-<FONT FACE="Courier New" SIZE=2>INSERT</FONT> and RB-<FONT FACE="Courier New" SIZE=2>DELETE</FONT> without requiring extra storage in the tree and without increasing the asymptotic running times. Show that while descending through <I>T</I>, we can determine the black-height of each node we visit in <I>O</I>(1) time per node visited.<P>We wish to implement the operation RB-<FONT FACE="Courier New" SIZE=2>JOIN</FONT>(<I>T</I><SUB>1</SUB>,<I>x</I>,<I>T</I><SUB>2</SUB>), which destroys <I>T</I><SUB>1</SUB> and <I>T</I><SUB>2</SUB> and returns a red-black tree <I>T</I> = <I>T</I><SUB>1</SUB> <IMG SRC="../IMAGES/wideu.gif"> {<I>x</I>} <IMG SRC="../IMAGES/wideu.gif"> <I>T</I><SUB>2</SUB>. Let <I>n</I> be the total number of nodes in <I>T</I><SUB>1</SUB> and <I>T</I><SUB>2</SUB>.<P><I><B>b.</I></B>     Assume without loss of generality that <I>bh</I>[<I>T</I><SUB>1</SUB>] <IMG SRC="../IMAGES/gteq.gif"> <I>bh</I>[<I>T</I><SUB>2</SUB>]. Describe an <I>O</I>(lg <I>n</I>)-time algorithm that finds a black node <I>y</I> in <I>T</I><SUB>1</SUB> with the largest key from among those nodes whose black-height is <I>bh</I>[<I>T</I><SUB>2</SUB>].<P><I><B>c.     </I></B>Let <I>T<SUB>y</I></SUB> be the subtree rooted at <I>y</I>. Describe how <I>T<SUB>y</I></SUB> can be replaced by <I>T<SUB>y</I></SUB> <IMG SRC="../IMAGES/wideu.gif"> {<I>x</I>}<IMG SRC="../IMAGES/wideu.gif"> <I>T</I><SUB>2</SUB> in <I>O</I>(1) time without destroying the binary-search-tree property.<P><I><B>d.     </I></B>What color should we make <I>x</I> so that red-black properties 1, 2, and 4 are maintained? Describe how property 3 can be enforced in <I>O</I>(lg <I>n</I>) time.<P><I><B>e.</I></B>     Argue that the running time of RB-<FONT FACE="Courier New" SIZE=2>JOIN</FONT> is <I>O</I>(lg <I>n</I>).<P><P><h1>Chapter notes</h1><P><a name="07f3_14ea"><a name="07f3_14eb"><a name="07f3_14ec"><a name="07f3_14ed"><a name="07f3_14ee">The idea of balancing a search tree is due to <img src="280_a.gif"> and Landis [2], who introduced a class of balanced search trees called &quot;AVL trees&quot; in 1962. Balance is maintained in AVL trees by rotations, but as many as <IMG SRC="../IMAGES/bound.gif">(lg <I>n</I>) rotations may be required after an insertion to maintain balance in an <I>n</I>-node tree. Another class of search trees, called &quot;2-3 trees,&quot; was introduced by J. E. Hopcroft (unpublished) in 1970. Balance is maintained in a 2-3 tree by manipulating the degrees of nodes in the tree. A generalization of 2-3 trees introduced by Bayer and McCreight [18], called B-trees, is the topic of Chapter 19.<P>Red-black trees were invented by Bayer [17] under the name &quot;symmetric binary B-trees.&quot; Guibas and Sedgewick [93] studied their properties at length and introduced the red/black color convention.<P><a name="07f3_14ef"><a name="07f3_14f0"><a name="07f3_14f1"><a name="07f3_14f2"><a name="07f3_14f3">Of the many other variations on balanced binary trees, perhaps the most intriguing are the &quot;splay trees&quot; introduced by Sleator and Tarjan [177], which are &quot;self-adjusting.&quot; (A good description of splay trees is given by Tarjan [188].) Splay trees maintain balance without any explicit balance condition such as color. Instead, &quot;splay operations&quot; (which involve rotations) are performed within the tree every time an access is made. The amortized cost (see Chapter 18) of each operation on an <I>n</I>-node tree is <I>O</I>(lg <I>n</I>). <P><P><P><P><center>Go to <a href="chap15.htm">Chapter 15</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Back to <a href="toc.htm">Table of Contents</A></P></center></BODY></HTML>